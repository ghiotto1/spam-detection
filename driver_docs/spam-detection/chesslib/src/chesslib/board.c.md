<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Chess board implementation with functions for board creation, move generation, and FEN string handling.

# Purpose
The code is a C implementation of a chess board management system. It provides functions to create and initialize a chess board, manage the state of the board, and generate legal moves. The code uses the Forsyth-Edwards Notation (FEN) to initialize the board state and to generate a FEN string from the current board state. The main components include functions for creating a board ([`boardCreate`](<#boardcreate>), [`boardCreateFromFen`](<#boardcreatefromfen>)), initializing a board in place ([`boardInitInPlace`](<#boardinitinplace>), [`boardInitFromFenInPlace`](<#boardinitfromfeninplace>)), setting and getting pieces on the board ([`boardSetPiece`](<#boardsetpiece>), [`boardGetPiece`](<#boardgetpiece>)), and generating legal moves ([`boardGenerateMoves`](<#boardgeneratemoves>)). The code also includes functions to check if a player is in check ([`boardIsInCheck`](<#boardisincheck>), [`boardIsPlayerInCheck`](<#boardisplayerincheck>)), if a square is attacked ([`boardIsSquareAttacked`](<#boardissquareattacked>)), and if the game is in a state of insufficient material ([`boardIsInsufficientMaterial`](<#boardisinsufficientmaterial>)).

The code defines a public API for managing chess board states and operations, which can be used in a larger chess application. It includes error handling for invalid FEN strings and ensures that moves are legal before they are executed. The code also handles special chess rules such as castling and en passant captures. The functions [`boardPlayMove`](<#boardplaymove>) and [`boardPlayMoveInPlace`](<#boardplaymoveinplace>) are used to apply moves to the board, updating the board state accordingly. The code is structured to be part of a larger chess library, as indicated by the inclusion of headers like `chesslib/board.h` and `chesslib/piecemoves.h`.
# Imports and Dependencies

---
- `stdio.h`
- `ctype.h`
- `stdlib.h`
- `string.h`
- `chesslib/board.h`
- `chesslib/piecemoves.h`


# Functions

---
### boardCreate<!-- {{#callable:boardCreate}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L14>)

Creates a new chess board initialized to the standard starting position using the FEN string.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls the [`boardCreateFromFen`](<#boardcreatefromfen>) function with the `INITIAL_FEN` constant as an argument.
    - Returns the result of the [`boardCreateFromFen`](<#boardcreatefromfen>) function call.
- **Output**: A pointer to a `board` structure initialized to the standard starting position, or `NULL` if initialization fails.
- **Functions Called**:
    - [`boardCreateFromFen`](<#boardcreatefromfen>)


---
### boardCreateFromFen<!-- {{#callable:boardCreateFromFen}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L19>)

Creates a new chess board from a given FEN string.
- **Inputs**:
    - `fen`: A string in Forsyth-Edwards Notation (FEN) that represents the state of a chess game.
- **Logic and Control Flow**:
    - Allocate memory for a new `board` structure.
    - Call [`boardInitFromFenInPlace`](<#boardinitfromfeninplace>) to initialize the board with the given FEN string.
    - If [`boardInitFromFenInPlace`](<#boardinitfromfeninplace>) returns a non-zero value, free the allocated memory and return `NULL`.
    - Return the pointer to the initialized `board` structure.
- **Output**: A pointer to a `board` structure initialized with the given FEN string, or `NULL` if initialization fails.
- **Functions Called**:
    - [`boardInitFromFenInPlace`](<#boardinitfromfeninplace>)


---
### boardInitInPlace<!-- {{#callable:boardInitInPlace}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L32>)

Initializes a chess board to the standard starting position using the FEN string for the initial setup.
- **Inputs**:
    - ``b``: A pointer to a `board` structure that will be initialized.
- **Logic and Control Flow**:
    - Calls the function [`boardInitFromFenInPlace`](<#boardinitfromfeninplace>) with the board pointer `b` and the constant `INITIAL_FEN` to set up the board.
- **Output**: No return value; the function modifies the board in place.
- **Functions Called**:
    - [`boardInitFromFenInPlace`](<#boardinitfromfeninplace>)


---
### boardInitFromFenInPlace<!-- {{#callable:boardInitFromFenInPlace}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L37>)

Initializes a chess board from a FEN string, setting up pieces, player turn, castling rights, en passant target, and move counters.
- **Inputs**:
    - ``b``: A pointer to a `board` structure where the function will initialize the board state.
    - ``fen``: A constant character pointer representing the FEN string that describes the board setup.
- **Logic and Control Flow**:
    - Initialize `currSq` to the top-left square of the board (file 1, rank 8).
    - Iterate over the FEN string to set up pieces on the board, handling numbers for empty squares, slashes for rank changes, and letters for piece types.
    - Check for errors such as misplaced slashes, unknown characters, or premature end of the FEN string, and return 1 if any errors are found.
    - After setting up pieces, read the current player's turn from the FEN string and update `b->currentPlayer`.
    - Parse the castling rights from the FEN string and update `b->castleState` accordingly.
    - Read the en passant target square from the FEN string and update `b->epTarget`.
    - Parse the half-move clock and full move number from the FEN string and update `b->halfMoveClock` and `b->moveNumber`.
    - Return 0 to indicate successful initialization.
- **Output**: Returns 0 on successful initialization, or 1 if there is an error in the FEN string.
- **Functions Called**:
    - [`sqI`](<square.c.md#sqi>)
    - [`boardSetPiece`](<#boardsetpiece>)
    - [`boardGetPiece`](<#boardgetpiece>)
    - [`sqS`](<square.c.md#sqs>)


---
### boardSetPiece<!-- {{#callable:boardSetPiece}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L246>)

Sets a chess piece on a specified square of the board.
- **Inputs**:
    - `b`: A pointer to the `board` structure where the piece will be set.
    - `s`: The `sq` (square) structure representing the position on the board where the piece will be placed.
    - `p`: The `piece` to be placed on the specified square.
- **Logic and Control Flow**:
    - Calculate the index of the square `s` using the [`sqGetIndex`](<square.c.md#sqgetindex>) function.
    - Assign the piece `p` to the calculated index in the `pieces` array of the board `b`.
- **Output**: No return value; the function modifies the board in place.
- **Functions Called**:
    - [`sqGetIndex`](<square.c.md#sqgetindex>)


---
### boardGetPiece<!-- {{#callable:boardGetPiece}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L252>)

Retrieves the chess piece located at a specific square on the board.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chessboard.
    - `s`: The `sq` structure representing the specific square on the board from which to retrieve the piece.
- **Logic and Control Flow**:
    - Calculate the index of the square `s` using the [`sqGetIndex`](<square.c.md#sqgetindex>) function.
    - Access the `pieces` array in the `board` structure `b` using the calculated index.
    - Return the piece located at the specified index.
- **Output**: The function returns a `piece` located at the specified square on the board.
- **Functions Called**:
    - [`sqGetIndex`](<square.c.md#sqgetindex>)


---
### boardGenerateMoves<!-- {{#callable:boardGenerateMoves}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L259>)

Generates a list of all legal moves for the current player on a chess board, including castling moves.
- **Inputs**:
    - `b`: A pointer to a `board` structure representing the current state of the chess game.
- **Logic and Control Flow**:
    - Create an empty `moveList` to store legal moves.
    - Iterate over each square on the board (64 squares total).
    - For each square, get the piece and check if it belongs to the current player.
    - Determine the type of piece and generate possible moves using the appropriate function for that piece type.
    - For each generated move, simulate the move on a copy of the board and check if the current player is in check after the move.
    - If the player is not in check, add the move to the `moveList`.
    - Check if castling is possible for the current player by verifying the positions of the king and rook, and ensuring the squares between them are not attacked or occupied.
    - Add valid castling moves to the `moveList`.
    - Return the `moveList` containing all legal moves.
- **Output**: A pointer to a `moveList` structure containing all legal moves for the current player, which must be freed after use.
- **Functions Called**:
    - [`moveListCreate`](<movelist.c.md#movelistcreate>)
    - [`sqIndex`](<square.c.md#sqindex>)
    - [`boardGetPiece`](<#boardgetpiece>)
    - [`pieceGetColor`](<piece.c.md#piecegetcolor>)
    - [`pieceGetType`](<piece.c.md#piecegettype>)
    - [`pmGetPawnMoves`](<piecemoves.c.md#pmgetpawnmoves>)
    - [`pmGetKnightMoves`](<piecemoves.c.md#pmgetknightmoves>)
    - [`pmGetBishopMoves`](<piecemoves.c.md#pmgetbishopmoves>)
    - [`pmGetRookMoves`](<piecemoves.c.md#pmgetrookmoves>)
    - [`pmGetQueenMoves`](<piecemoves.c.md#pmgetqueenmoves>)
    - [`pmGetKingMoves`](<piecemoves.c.md#pmgetkingmoves>)
    - [`boardPlayMoveInPlace`](<#boardplaymoveinplace>)
    - [`boardIsPlayerInCheck`](<#boardisplayerincheck>)
    - [`moveListAdd`](<movelist.c.md#movelistadd>)
    - [`moveListFree`](<movelist.c.md#movelistfree>)
    - [`sqI`](<square.c.md#sqi>)
    - [`boardIsSquareAttacked`](<#boardissquareattacked>)
    - [`moveSq`](<move.c.md#movesq>)


---
### boardIsSquareAttacked<!-- {{#callable:boardIsSquareAttacked}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L361>)

Checks if a specific square on a chess board is attacked by any piece of a given color.
- **Inputs**:
    - ``b``: A pointer to the `board` structure representing the current state of the chess board.
    - ``s``: The square (`sq` type) to check for an attack.
    - ``attacker``: The color of the pieces (`pieceColor` type) that might be attacking the square.
- **Logic and Control Flow**:
    - Iterates over all 64 squares on the board to find pieces of the specified `attacker` color.
    - For each piece found, determines its type and retrieves its possible attack moves using the appropriate function for that piece type.
    - Checks if any of the possible moves for the piece attacks the specified square `s`.
    - If a move attacks the square, returns `1` indicating the square is attacked.
    - If no attacking move is found after checking all pieces, returns `0`.
- **Output**: Returns `1` if the square is attacked by a piece of the specified color, otherwise returns `0`.
- **Functions Called**:
    - [`sqIndex`](<square.c.md#sqindex>)
    - [`boardGetPiece`](<#boardgetpiece>)
    - [`pieceGetColor`](<piece.c.md#piecegetcolor>)
    - [`pieceGetType`](<piece.c.md#piecegettype>)
    - [`pmGetPawnAttacks`](<piecemoves.c.md#pmgetpawnattacks>)
    - [`pmGetKnightMoves`](<piecemoves.c.md#pmgetknightmoves>)
    - [`pmGetBishopMoves`](<piecemoves.c.md#pmgetbishopmoves>)
    - [`pmGetRookMoves`](<piecemoves.c.md#pmgetrookmoves>)
    - [`pmGetQueenMoves`](<piecemoves.c.md#pmgetqueenmoves>)
    - [`pmGetKingMoves`](<piecemoves.c.md#pmgetkingmoves>)
    - [`sqEq`](<square.c.md#sqeq>)
    - [`moveListFree`](<movelist.c.md#movelistfree>)


---
### boardIsInCheck<!-- {{#callable:boardIsInCheck}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L425>)

Checks if the current player on the board is in check.
- **Inputs**:
    - ``b``: A pointer to a `board` structure representing the current state of the chess board.
- **Logic and Control Flow**:
    - Calls the function [`boardIsPlayerInCheck`](<#boardisplayerincheck>) with the board `b` and the current player `b->currentPlayer` as arguments.
    - Returns the result of [`boardIsPlayerInCheck`](<#boardisplayerincheck>), which indicates if the current player is in check.
- **Output**: Returns a `uint8_t` value, where `1` indicates the current player is in check and `0` indicates they are not.
- **Functions Called**:
    - [`boardIsPlayerInCheck`](<#boardisplayerincheck>)


---
### boardIsPlayerInCheck<!-- {{#callable:boardIsPlayerInCheck}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L430>)

Checks if the player's king is in check on the given board.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chessboard.
    - `player`: The `pieceColor` representing the player whose king is being checked for check status.
- **Logic and Control Flow**:
    - Determine the player's king piece (`pWKing` for white, `pBKing` for black) and the opponent's color.
    - Iterate over all 64 squares of the board to find the player's king.
    - If the king is found, check if the square is attacked by the opponent using [`boardIsSquareAttacked`](<#boardissquareattacked>).
    - If the square is attacked, return 1 indicating the king is in check.
    - If the loop completes without finding the king in check, return 0.
- **Output**: Returns `1` if the player's king is in check, otherwise returns `0`.
- **Functions Called**:
    - [`sqIndex`](<square.c.md#sqindex>)
    - [`boardGetPiece`](<#boardgetpiece>)
    - [`boardIsSquareAttacked`](<#boardissquareattacked>)


---
### boardIsInsufficientMaterial<!-- {{#callable:boardIsInsufficientMaterial}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L446>)

Determines if a chess board position has insufficient material to checkmate, resulting in a draw.
- **Inputs**:
    - ``b``: A pointer to a `board` structure representing the current state of the chess board.
- **Logic and Control Flow**:
    - Initialize counters for pieces, knights, bishops on dark squares, bishops on light squares, white kings, and black kings.
    - Iterate over all 64 squares of the board to count the number of each type of piece.
    - Check if only kings are present; if true, return 1 indicating a draw due to insufficient material.
    - Check if there is one white king and one black king, and if the total number of pieces equals the sum of kings, knights, and bishops.
    - If there are only two kings and one minor piece (knight or bishop), return 1 indicating a draw.
    - If there are only two kings and bishops all on the same color, return 1 indicating a draw.
    - If none of the conditions for insufficient material are met, return 0.
- **Output**: Returns `1` if the board position is a draw due to insufficient material, otherwise returns `0`.
- **Functions Called**:
    - [`sqIndex`](<square.c.md#sqindex>)
    - [`boardGetPiece`](<#boardgetpiece>)
    - [`pieceGetType`](<piece.c.md#piecegettype>)
    - [`sqIsDark`](<square.c.md#sqisdark>)


---
### boardPlayMove<!-- {{#callable:boardPlayMove}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L509>)

Creates a new board by copying the current board and applying a specified move.
- **Inputs**:
    - ``b``: A pointer to the current `board` structure that represents the current state of the chess game.
    - ``m``: A `move` structure that specifies the move to be applied to the board.
- **Logic and Control Flow**:
    - Allocate memory for a new `board` structure and assign it to `newBoard`.
    - Copy the contents of the current board `b` into `newBoard` using `memcpy`.
    - Call [`boardPlayMoveInPlace`](<#boardplaymoveinplace>) to apply the move `m` to `newBoard`.
    - Return the pointer to the newly created `newBoard`.
- **Output**: A pointer to a new `board` structure that represents the state of the board after the move `m` has been applied.
- **Functions Called**:
    - [`boardPlayMoveInPlace`](<#boardplaymoveinplace>)


---
### boardPlayMoveInPlace<!-- {{#callable:boardPlayMoveInPlace}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L521>)

Updates the chess board state by executing a given move, including handling special moves like castling and en passant, and switches the current player.
- **Inputs**:
    - ``b``: A pointer to the `board` structure representing the current state of the chess game.
    - ``m``: A `move` structure representing the move to be played on the board.
- **Logic and Control Flow**:
    - If the current player is black, increment the move number.
    - Determine the type of piece being moved and update the half-move clock accordingly.
    - Check if the move is a castling move and update the board state by moving the rook to the correct position and updating the castling rights.
    - If a rook moves or is captured, update the castling rights accordingly.
    - Check for en passant captures and remove the captured pawn if applicable.
    - Move the piece to the new position, handling pawn promotion if specified.
    - Update the en passant target square if a pawn moves two squares forward, otherwise set it to invalid.
    - Switch the current player to the other player.
- **Output**: The function does not return a value; it modifies the board state in place.
- **Functions Called**:
    - [`pieceGetType`](<piece.c.md#piecegettype>)
    - [`boardGetPiece`](<#boardgetpiece>)
    - [`boardSetPiece`](<#boardsetpiece>)
    - [`sqI`](<square.c.md#sqi>)
    - [`sqEq`](<square.c.md#sqeq>)
    - [`pieceMake`](<piece.c.md#piecemake>)


---
### boardEq<!-- {{#callable:boardEq}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L607>)

Compares two chess boards to determine if they are fully equal.
- **Inputs**:
    - `b1`: Pointer to the first `board` structure to compare.
    - `b2`: Pointer to the second `board` structure to compare.
- **Logic and Control Flow**:
    - Check if `currentPlayer` of `b1` and `b2` are different; if so, return 0.
    - Check if `castleState` of `b1` and `b2` are different; if so, return 0.
    - Use [`sqEq`](<square.c.md#sqeq>) to compare `epTarget` of `b1` and `b2`; if they are not equal, return 0.
    - Check if `halfMoveClock` of `b1` and `b2` are different; if so, return 0.
    - Check if `moveNumber` of `b1` and `b2` are different; if so, return 0.
    - Use `memcmp` to compare the memory of `b1` and `b2` for the first 64 pieces; if they differ, return 0.
    - If all checks pass, return 1.
- **Output**: Returns `1` if the boards are fully equal, otherwise returns `0`.
- **Functions Called**:
    - [`sqEq`](<square.c.md#sqeq>)


---
### boardEqContext<!-- {{#callable:boardEqContext}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L631>)

Compares two chess boards for contextual equality, ignoring move counters and filtering en passant target squares.
- **Inputs**:
    - `b1`: Pointer to the first `board` structure to compare.
    - `b2`: Pointer to the second `board` structure to compare.
- **Logic and Control Flow**:
    - Check if the `currentPlayer` fields of `b1` and `b2` are equal; return 0 if not.
    - Check if the `castleState` fields of `b1` and `b2` are equal; return 0 if not.
    - Use `memcmp` to compare the first 64 pieces of `b1` and `b2`; return 0 if they differ.
    - Filter the en passant target square for `b1` by checking if any pawns can attack it; set to `SQ_INVALID` if not.
    - Filter the en passant target square for `b2` similarly.
    - Compare the filtered en passant target squares of `b1` and `b2`; return 0 if they differ.
    - Return 1 if all checks pass, indicating contextual equality.
- **Output**: Returns `1` if the boards are contextually equal, otherwise returns `0`.
- **Functions Called**:
    - [`sqEq`](<square.c.md#sqeq>)
    - [`sqI`](<square.c.md#sqi>)
    - [`boardGetPiece`](<#boardgetpiece>)
    - [`boardPlayMoveInPlace`](<#boardplaymoveinplace>)
    - [`moveSq`](<move.c.md#movesq>)
    - [`boardIsPlayerInCheck`](<#boardisplayerincheck>)


---
### boardGetFen<!-- {{#callable:boardGetFen}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L716>)

Generates a FEN string representation of the current state of a chess board.
- **Inputs**:
    - `b`: A pointer to a `board` structure representing the current state of the chess game.
- **Logic and Control Flow**:
    - Initialize a buffer `buf` to store the FEN string and a pointer `c` to iterate over the buffer.
    - Iterate over each rank from 8 to 1 and each file from 1 to 8 to process the board's pieces.
    - For each square, check if it contains a piece; if so, append the piece's letter to the buffer, otherwise count the number of consecutive empty squares.
    - After processing a rank, append the count of empty squares if any, and add a '/' if not the last rank.
    - Append the current player's turn ('w' for white, 'b' for black) to the buffer.
    - Append the castling availability to the buffer, using 'K', 'Q', 'k', 'q' for available castling rights or '-' if none.
    - Append the en passant target square or '-' if there is no target.
    - Use `sprintf` to append the half move clock and move number to the buffer.
    - Allocate memory for the FEN string, copy the buffer content to it, and return the allocated string.
- **Output**: A dynamically allocated string containing the FEN representation of the board, which must be freed by the caller.
- **Functions Called**:
    - [`sqI`](<square.c.md#sqi>)
    - [`boardGetPiece`](<#boardgetpiece>)
    - [`pieceGetLetter`](<piece.c.md#piecegetletter>)
    - [`sqEq`](<square.c.md#sqeq>)
    - [`sqGetStr`](<square.c.md#sqgetstr>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)