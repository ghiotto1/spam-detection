<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Chess board implementation with functions for board creation, move generation, and FEN string handling.

# Purpose
The code is a C implementation of a chess board management system. It provides functions to create and initialize a chess board, manage the state of the board, and generate legal moves. The code uses the Forsyth-Edwards Notation (FEN) to initialize and represent the board state, allowing for the setup of specific board configurations. The main components include functions for creating a board ([`boardCreate`](<#boardcreate>), [`boardCreateFromFen`](<#boardcreatefromfen>)), initializing a board in place ([`boardInitInPlace`](<#boardinitinplace>), [`boardInitFromFenInPlace`](<#boardinitfromfeninplace>)), setting and getting pieces on the board ([`boardSetPiece`](<#boardsetpiece>), [`boardGetPiece`](<#boardgetpiece>)), and generating legal moves ([`boardGenerateMoves`](<#boardgeneratemoves>)). The code also includes functions to check if a player is in check ([`boardIsInCheck`](<#boardisincheck>), [`boardIsPlayerInCheck`](<#boardisplayerincheck>)), determine if a board state is a draw due to insufficient material ([`boardIsInsufficientMaterial`](<#boardisinsufficientmaterial>)), and play moves on the board ([`boardPlayMove`](<#boardplaymove>), [`boardPlayMoveInPlace`](<#boardplaymoveinplace>)).

The code defines a public API for interacting with the chess board, including functions to compare board states ([`boardEq`](<#boardeq>), [`boardEqContext`](<#boardeqcontext>)) and convert a board state to a FEN string ([`boardGetFen`](<#boardgetfen>)). It handles special chess rules such as castling and en passant, and includes error checking for FEN string parsing. The code is intended to be part of a larger chess library, as indicated by the inclusion of headers like `chesslib/board.h` and `chesslib/piecemoves.h`. The functions provided are designed to be used by other parts of a chess program to manage and manipulate the state of a chess game.
# Imports and Dependencies

---
- `stdio.h`
- `ctype.h`
- `stdlib.h`
- `string.h`
- `chesslib/board.h`
- `chesslib/piecemoves.h`


# Functions

---
### boardCreate<!-- {{#callable:boardCreate}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L14>)

Creates a new chess board initialized to the standard starting position using the FEN string.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls the [`boardCreateFromFen`](<#boardcreatefromfen>) function with the `INITIAL_FEN` constant as an argument.
    - Returns the result of the [`boardCreateFromFen`](<#boardcreatefromfen>) function call.
- **Output**: A pointer to a `board` structure initialized to the standard starting position, or `NULL` if initialization fails.
- **Functions Called**:
    - [`boardCreateFromFen`](<#boardcreatefromfen>)


---
### boardCreateFromFen<!-- {{#callable:boardCreateFromFen}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L19>)

Creates a new chess board from a given FEN string.
- **Inputs**:
    - `fen`: A string in Forsyth-Edwards Notation (FEN) that represents the state of a chess game.
- **Logic and Control Flow**:
    - Allocate memory for a new `board` structure.
    - Call [`boardInitFromFenInPlace`](<#boardinitfromfeninplace>) to initialize the board with the given FEN string.
    - If [`boardInitFromFenInPlace`](<#boardinitfromfeninplace>) returns a non-zero value, free the allocated memory and return `NULL`.
    - If initialization is successful, return the pointer to the newly created board.
- **Output**: A pointer to a `board` structure initialized with the given FEN string, or `NULL` if initialization fails.
- **Functions Called**:
    - [`boardInitFromFenInPlace`](<#boardinitfromfeninplace>)


---
### boardInitInPlace<!-- {{#callable:boardInitInPlace}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L32>)

Initializes a chess board to the standard starting position using the FEN string.
- **Inputs**:
    - ``b``: A pointer to a `board` structure that will be initialized.
- **Logic and Control Flow**:
    - Calls the function [`boardInitFromFenInPlace`](<#boardinitfromfeninplace>) with the board pointer `b` and the constant `INITIAL_FEN` to set up the board.
- **Output**: No return value; the function modifies the board in place.
- **Functions Called**:
    - [`boardInitFromFenInPlace`](<#boardinitfromfeninplace>)


---
### boardInitFromFenInPlace<!-- {{#callable:boardInitFromFenInPlace}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L37>)

Initializes a chess board from a FEN string and updates the board state accordingly.
- **Inputs**:
    - `b`: A pointer to a `board` structure that will be initialized.
    - `fen`: A constant character pointer representing the FEN string to parse.
- **Logic and Control Flow**:
    - Initialize `currSq` to the top-left square of the board (file 1, rank 8).
    - Iterate over the FEN string to read piece positions, updating `currSq` and setting pieces on the board using [`boardSetPiece`](<#boardsetpiece>).
    - Handle numbers in the FEN string by skipping empty squares and updating `currSq`.
    - Handle '/' characters to move to the next rank, checking for errors in rank positioning.
    - Parse individual piece characters, determining color and type, and place them on the board.
    - After reading pieces, check if the board setup ended correctly with `currSq` at file 9, rank 1.
    - Parse the current player's turn ('w' or 'b') and update `b->currentPlayer`.
    - Parse the castling availability section, updating `b->castleState` based on the presence of kings and rooks in their initial positions.
    - Parse the en passant target square, updating `b->epTarget` or setting it to `SQ_INVALID` if '-' is found.
    - Parse the half move clock and full move count using `sscanf` to update `b->halfMoveClock` and `b->moveNumber`.
- **Output**: Returns 0 on successful initialization, or 1 if an error occurs in parsing the FEN string.
- **Functions Called**:
    - [`sqI`](<square.c.md#sqi>)
    - [`boardSetPiece`](<#boardsetpiece>)
    - [`boardGetPiece`](<#boardgetpiece>)
    - [`sqS`](<square.c.md#sqs>)


---
### boardSetPiece<!-- {{#callable:boardSetPiece}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L246>)

Sets a chess piece on a specified square of the board.
- **Inputs**:
    - `b`: A pointer to the `board` structure where the piece will be set.
    - `s`: The `sq` type representing the square on the board where the piece will be placed.
    - `p`: The `piece` type representing the chess piece to be placed on the board.
- **Logic and Control Flow**:
    - Get the index of the square `s` using the [`sqGetIndex`](<square.c.md#sqgetindex>) function.
    - Set the piece `p` at the calculated index in the `pieces` array of the board `b`.
- **Output**: No output; the function modifies the board in place.
- **Functions Called**:
    - [`sqGetIndex`](<square.c.md#sqgetindex>)


---
### boardGetPiece<!-- {{#callable:boardGetPiece}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L252>)

Retrieves the chess piece located at a specific square on the board.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chessboard.
    - `s`: The `sq` structure representing the specific square on the board from which to retrieve the piece.
- **Logic and Control Flow**:
    - Calculate the index of the square `s` using the [`sqGetIndex`](<square.c.md#sqgetindex>) function.
    - Access the `pieces` array of the `board` structure `b` using the calculated index.
    - Return the piece located at the specified index.
- **Output**: The function returns a `piece` type, which represents the chess piece located at the specified square on the board.
- **Functions Called**:
    - [`sqGetIndex`](<square.c.md#sqgetindex>)


---
### boardGenerateMoves<!-- {{#callable:boardGenerateMoves}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L259>)

Generates a list of all legal moves for the current player on a chess board, including castling moves.
- **Inputs**:
    - `b`: A pointer to a `board` structure representing the current state of the chess game.
- **Logic and Control Flow**:
    - Create an empty `moveList` to store legal moves.
    - Iterate over each square on the board (64 squares total).
    - For each square, get the piece and check if it belongs to the current player.
    - Determine the type of piece and generate possible moves using specific functions for each piece type (pawn, knight, bishop, rook, queen, king).
    - For each generated move, simulate the move on a copy of the board and check if the current player is not in check after the move.
    - Add the move to the `moveList` if it is legal (does not leave the player in check).
    - Check for possible castling moves (both kingside and queenside) and add them to the `moveList` if they are legal.
    - Return the `moveList` containing all legal moves.
- **Output**: A pointer to a `moveList` structure containing all legal moves for the current player, which must be freed after use.
- **Functions Called**:
    - [`moveListCreate`](<movelist.c.md#movelistcreate>)
    - [`sqIndex`](<square.c.md#sqindex>)
    - [`boardGetPiece`](<#boardgetpiece>)
    - [`pieceGetColor`](<piece.c.md#piecegetcolor>)
    - [`pieceGetType`](<piece.c.md#piecegettype>)
    - [`pmGetPawnMoves`](<piecemoves.c.md#pmgetpawnmoves>)
    - [`pmGetKnightMoves`](<piecemoves.c.md#pmgetknightmoves>)
    - [`pmGetBishopMoves`](<piecemoves.c.md#pmgetbishopmoves>)
    - [`pmGetRookMoves`](<piecemoves.c.md#pmgetrookmoves>)
    - [`pmGetQueenMoves`](<piecemoves.c.md#pmgetqueenmoves>)
    - [`pmGetKingMoves`](<piecemoves.c.md#pmgetkingmoves>)
    - [`boardPlayMoveInPlace`](<#boardplaymoveinplace>)
    - [`boardIsPlayerInCheck`](<#boardisplayerincheck>)
    - [`moveListAdd`](<movelist.c.md#movelistadd>)
    - [`moveListFree`](<movelist.c.md#movelistfree>)
    - [`sqI`](<square.c.md#sqi>)
    - [`boardIsSquareAttacked`](<#boardissquareattacked>)
    - [`moveSq`](<move.c.md#movesq>)


---
### boardIsSquareAttacked<!-- {{#callable:boardIsSquareAttacked}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L361>)

Checks if a specific square on a chess board is attacked by any piece of a given color.
- **Inputs**:
    - ``b``: A pointer to the `board` structure representing the current state of the chess board.
    - ``s``: The square (`sq` type) to check for an attack.
    - ``attacker``: The color of the pieces (`pieceColor` type) that might be attacking the square.
- **Logic and Control Flow**:
    - Iterates over all 64 squares on the board to find pieces of the specified `attacker` color.
    - For each piece found, determines its type and retrieves its possible attack moves using the appropriate function ([`pmGetPawnAttacks`](<piecemoves.c.md#pmgetpawnattacks>), [`pmGetKnightMoves`](<piecemoves.c.md#pmgetknightmoves>), etc.).
    - Checks if any of the possible moves for the piece attacks the specified square `s`.
    - If a move is found that attacks `s`, returns 1 immediately.
    - If no attacking move is found after checking all pieces, returns 0.
- **Output**: Returns `1` if the square is attacked by any piece of the specified color, otherwise returns `0`.
- **Functions Called**:
    - [`sqIndex`](<square.c.md#sqindex>)
    - [`boardGetPiece`](<#boardgetpiece>)
    - [`pieceGetColor`](<piece.c.md#piecegetcolor>)
    - [`pieceGetType`](<piece.c.md#piecegettype>)
    - [`pmGetPawnAttacks`](<piecemoves.c.md#pmgetpawnattacks>)
    - [`pmGetKnightMoves`](<piecemoves.c.md#pmgetknightmoves>)
    - [`pmGetBishopMoves`](<piecemoves.c.md#pmgetbishopmoves>)
    - [`pmGetRookMoves`](<piecemoves.c.md#pmgetrookmoves>)
    - [`pmGetQueenMoves`](<piecemoves.c.md#pmgetqueenmoves>)
    - [`pmGetKingMoves`](<piecemoves.c.md#pmgetkingmoves>)
    - [`sqEq`](<square.c.md#sqeq>)
    - [`moveListFree`](<movelist.c.md#movelistfree>)


---
### boardIsInCheck<!-- {{#callable:boardIsInCheck}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L425>)

Checks if the current player on the board is in check.
- **Inputs**:
    - `b`: A pointer to a `board` structure representing the current state of the chess game.
- **Logic and Control Flow**:
    - Calls the function [`boardIsPlayerInCheck`](<#boardisplayerincheck>) with the board `b` and the current player `b->currentPlayer` as arguments.
    - Returns the result of [`boardIsPlayerInCheck`](<#boardisplayerincheck>), which indicates if the current player is in check.
- **Output**: Returns a `uint8_t` value, where `1` indicates the current player is in check and `0` indicates they are not.
- **Functions Called**:
    - [`boardIsPlayerInCheck`](<#boardisplayerincheck>)


---
### boardIsPlayerInCheck<!-- {{#callable:boardIsPlayerInCheck}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L430>)

Checks if the specified player's king is in check on the given chess board.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chess board.
    - `player`: The `pieceColor` enumeration value representing the player whose king's check status is being evaluated.
- **Logic and Control Flow**:
    - Determine the `royalPiece` as the king piece of the specified player (`pWKing` for white, `pBKing` for black).
    - Determine the `otherColor` as the opposite color of the specified player (`pcBlack` for white, `pcWhite` for black).
    - Iterate over all 64 squares of the board using a loop.
    - For each square, check if the piece is the `royalPiece`.
    - If the `royalPiece` is found, check if the square is attacked by the `otherColor` using [`boardIsSquareAttacked`](<#boardissquareattacked>).
    - If the square is attacked, return 1 indicating the player is in check.
    - If no square with the `royalPiece` is attacked, return 0 indicating the player is not in check.
- **Output**: Returns `1` if the player's king is in check, otherwise returns `0`.
- **Functions Called**:
    - [`sqIndex`](<square.c.md#sqindex>)
    - [`boardGetPiece`](<#boardgetpiece>)
    - [`boardIsSquareAttacked`](<#boardissquareattacked>)


---
### boardIsInsufficientMaterial<!-- {{#callable:boardIsInsufficientMaterial}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L446>)

Determines if a chess board position has insufficient material to checkmate, resulting in a draw.
- **Inputs**:
    - `b`: A pointer to a `board` structure representing the current state of the chess board.
- **Logic and Control Flow**:
    - Initialize counters for pieces, knights, bishops on dark squares, bishops on light squares, white kings, and black kings.
    - Iterate over all 64 squares of the board to count the number of each type of piece.
    - If only kings are present, return 1 indicating a draw due to insufficient material.
    - If there is one white king and one black king, check for conditions with minor pieces that result in a draw:
    - If there are only two kings and one minor piece, return 1 indicating a draw.
    - If there are only two kings and bishops all on the same color, return 1 indicating a draw.
    - If none of the draw conditions are met, return 0 indicating sufficient material for checkmate.
- **Output**: Returns `1` if the board position is a draw due to insufficient material, otherwise returns `0`.
- **Functions Called**:
    - [`sqIndex`](<square.c.md#sqindex>)
    - [`boardGetPiece`](<#boardgetpiece>)
    - [`pieceGetType`](<piece.c.md#piecegettype>)
    - [`sqIsDark`](<square.c.md#sqisdark>)


---
### boardPlayMove<!-- {{#callable:boardPlayMove}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L509>)

Creates a new board by copying the current board and applying a specified move.
- **Inputs**:
    - ``b``: A pointer to the current `board` structure that represents the current state of the chess game.
    - ``m``: A `move` structure that specifies the move to be applied to the board.
- **Logic and Control Flow**:
    - Allocate memory for a new `board` structure and assign it to `newBoard`.
    - Copy the contents of the current board `b` into `newBoard` using `memcpy`.
    - Call [`boardPlayMoveInPlace`](<#boardplaymoveinplace>) to apply the move `m` to `newBoard`.
    - Return the pointer to the newly created `newBoard`.
- **Output**: A pointer to a new `board` structure that represents the state of the board after the move `m` has been applied.
- **Functions Called**:
    - [`boardPlayMoveInPlace`](<#boardplaymoveinplace>)


---
### boardPlayMoveInPlace<!-- {{#callable:boardPlayMoveInPlace}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L521>)

Updates the chess board state by executing a given move, handling special cases like castling, en passant, and pawn promotion.
- **Inputs**:
    - ``b``: A pointer to the `board` structure representing the current state of the chess game.
    - ``m``: A `move` structure representing the move to be played on the board.
- **Logic and Control Flow**:
    - If the current player is black, increment the move number.
    - Determine the type of piece being moved and update the half-move clock accordingly.
    - Check if the move is a castling move and update the board state by moving the rook and clearing the castling rights.
    - If a rook moves or is captured, update the castling rights accordingly.
    - Check for en passant capture and remove the captured pawn if applicable.
    - Move the piece to the target square, handling pawn promotion if specified.
    - Update the en passant target square if a pawn moves two squares forward.
    - Switch the current player to the other player.
- **Output**: No return value; the function modifies the board state in place.
- **Functions Called**:
    - [`pieceGetType`](<piece.c.md#piecegettype>)
    - [`boardGetPiece`](<#boardgetpiece>)
    - [`boardSetPiece`](<#boardsetpiece>)
    - [`sqI`](<square.c.md#sqi>)
    - [`sqEq`](<square.c.md#sqeq>)
    - [`pieceMake`](<piece.c.md#piecemake>)


---
### boardEq<!-- {{#callable:boardEq}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L607>)

Compares two chess boards to determine if they are fully equal.
- **Inputs**:
    - `b1`: Pointer to the first `board` structure to compare.
    - `b2`: Pointer to the second `board` structure to compare.
- **Logic and Control Flow**:
    - Check if `currentPlayer` of `b1` and `b2` are different; if so, return 0.
    - Check if `castleState` of `b1` and `b2` are different; if so, return 0.
    - Use [`sqEq`](<square.c.md#sqeq>) to compare `epTarget` of `b1` and `b2`; if they are not equal, return 0.
    - Check if `halfMoveClock` of `b1` and `b2` are different; if so, return 0.
    - Check if `moveNumber` of `b1` and `b2` are different; if so, return 0.
    - Use `memcmp` to compare the memory of `b1` and `b2` for the first 64 pieces; if they differ, return 0.
    - If all checks pass, return 1.
- **Output**: Returns `1` if the boards are fully equal, otherwise returns `0`.
- **Functions Called**:
    - [`sqEq`](<square.c.md#sqeq>)


---
### boardEqContext<!-- {{#callable:boardEqContext}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L631>)

Compares two chess boards for contextual equality, ignoring move counters and filtering en passant target squares.
- **Inputs**:
    - `b1`: Pointer to the first `board` structure to compare.
    - `b2`: Pointer to the second `board` structure to compare.
- **Logic and Control Flow**:
    - Check if the `currentPlayer` fields of `b1` and `b2` are equal; return 0 if not.
    - Check if the `castleState` fields of `b1` and `b2` are equal; return 0 if not.
    - Use `memcmp` to compare the first 64 pieces of `b1` and `b2`; return 0 if they differ.
    - Filter the en passant target square for `b1` by checking if any pawns can attack it; set to `SQ_INVALID` if not.
    - Filter the en passant target square for `b2` similarly.
    - Compare the filtered en passant target squares of `b1` and `b2`; return 0 if they differ.
    - Return 1 if all checks pass, indicating contextual equality.
- **Output**: Returns `1` if the boards are contextually equal, otherwise returns `0`.
- **Functions Called**:
    - [`sqEq`](<square.c.md#sqeq>)
    - [`sqI`](<square.c.md#sqi>)
    - [`boardGetPiece`](<#boardgetpiece>)
    - [`boardPlayMoveInPlace`](<#boardplaymoveinplace>)
    - [`moveSq`](<move.c.md#movesq>)
    - [`boardIsPlayerInCheck`](<#boardisplayerincheck>)


---
### boardGetFen<!-- {{#callable:boardGetFen}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L716>)

Generates a FEN (Forsyth-Edwards Notation) string representation of a chess board state.
- **Inputs**:
    - `b`: A pointer to a `board` structure representing the current state of the chess board.
- **Logic and Control Flow**:
    - Initialize a buffer `buf` to store the FEN string and a pointer `c` to iterate over the buffer.
    - Iterate over each rank from 8 to 1 and each file from 1 to 8 to process each square on the board.
    - For each square, check if it contains a piece; if so, append the piece's letter to the buffer, otherwise increment a blank counter.
    - If blanks are present before a piece, append the number of blanks to the buffer.
    - After processing each rank, append a '/' to separate ranks, except after the last rank.
    - Append a space and the current player's turn ('w' for white, 'b' for black) to the buffer.
    - Append a space and the castling availability (e.g., 'KQkq' or '-') to the buffer.
    - Append a space and the en passant target square or '-' if there is none.
    - Append a space and the half move clock and move number using `sprintf`.
    - Calculate the length of the buffer, allocate memory for the FEN string, copy the buffer to the allocated memory, and return the FEN string.
- **Output**: A dynamically allocated string containing the FEN representation of the board, which must be freed by the caller.
- **Functions Called**:
    - [`sqI`](<square.c.md#sqi>)
    - [`boardGetPiece`](<#boardgetpiece>)
    - [`pieceGetLetter`](<piece.c.md#piecegetletter>)
    - [`sqEq`](<square.c.md#sqeq>)
    - [`sqGetStr`](<square.c.md#sqgetstr>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)