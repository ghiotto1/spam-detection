<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Chess board implementation with functions for board creation, move generation, and FEN string handling.

# Purpose
The code is a C implementation of a chess board management system. It provides functions to create, initialize, and manipulate a chess board using the Forsyth-Edwards Notation (FEN) for setting up board positions. The code includes functions to create a board from a FEN string, initialize a board in place, and set or get pieces on the board. It also includes functions to generate legal moves, check if a square is attacked, and determine if a player is in check. The code handles special chess rules such as castling, en passant, and pawn promotion.

The code defines several functions that interact with a `board` structure, which represents the state of a chess game. It includes functions to play moves on the board, check for insufficient material for a draw, and compare boards for equality. The code also provides a function to convert the board state back into a FEN string. This implementation is part of a larger chess library, as indicated by the inclusion of headers like `chesslib/board.h` and `chesslib/piecemoves.h`. The code is designed to be used as part of a chess engine or application that requires board state management and move generation.
# Imports and Dependencies

---
- `stdio.h`
- `ctype.h`
- `stdlib.h`
- `string.h`
- `chesslib/board.h`
- `chesslib/piecemoves.h`


# Functions

---
### boardCreate<!-- {{#callable:boardCreate}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L14>)

Creates a new chess board initialized to the standard starting position using the FEN string.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls the [`boardCreateFromFen`](<#boardcreatefromfen>) function with the `INITIAL_FEN` constant as an argument.
    - Returns the result of the [`boardCreateFromFen`](<#boardcreatefromfen>) function call.
- **Output**: A pointer to a `board` structure initialized to the standard starting position, or `NULL` if initialization fails.
- **Functions Called**:
    - [`boardCreateFromFen`](<#boardcreatefromfen>)


---
### boardCreateFromFen<!-- {{#callable:boardCreateFromFen}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L19>)

Creates a new chess board from a given FEN string.
- **Inputs**:
    - `fen`: A string in Forsyth-Edwards Notation (FEN) that represents the state of a chess game.
- **Logic and Control Flow**:
    - Allocate memory for a new `board` structure and assign it to pointer `b`.
    - Call [`boardInitFromFenInPlace`](<#boardinitfromfeninplace>) to initialize the board `b` using the provided `fen` string.
    - If [`boardInitFromFenInPlace`](<#boardinitfromfeninplace>) returns a non-zero value, indicating an error, free the allocated memory for `b` and return `NULL`.
    - If initialization is successful, return the pointer `b` to the newly created board.
- **Output**: A pointer to a `board` structure initialized with the given FEN string, or `NULL` if initialization fails.
- **Functions Called**:
    - [`boardInitFromFenInPlace`](<#boardinitfromfeninplace>)


---
### boardInitInPlace<!-- {{#callable:boardInitInPlace}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L32>)

Initializes a chess board to the standard starting position using the FEN string for the initial setup.
- **Inputs**:
    - `b`: A pointer to a `board` structure that will be initialized.
- **Logic and Control Flow**:
    - Calls the function [`boardInitFromFenInPlace`](<#boardinitfromfeninplace>) with the board pointer `b` and the constant `INITIAL_FEN` to set up the board.
- **Output**: No return value; the function modifies the board in place.
- **Functions Called**:
    - [`boardInitFromFenInPlace`](<#boardinitfromfeninplace>)


---
### boardInitFromFenInPlace<!-- {{#callable:boardInitFromFenInPlace}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L37>)

Initializes a chess board from a FEN string and updates the board state accordingly.
- **Inputs**:
    - `b`: A pointer to a `board` structure that will be initialized.
    - `fen`: A constant character pointer representing the FEN string to parse.
- **Logic and Control Flow**:
    - Initialize `currSq` to the top-left square of the board (file 1, rank 8).
    - Iterate over the FEN string to read piece placement, updating `currSq` and setting pieces on the board using [`boardSetPiece`](<#boardsetpiece>).
    - Handle numbers in the FEN string by skipping empty squares and updating `currSq`.
    - Handle '/' characters to move to the next rank, checking for errors in rank positioning.
    - Parse individual piece characters, determining color and type, and place them on the board.
    - After reading pieces, check if the board setup ended correctly with `currSq` at file 9, rank 1.
    - Parse the current player's turn ('w' or 'b') and update `b->currentPlayer`.
    - Parse the castling availability section, updating `b->castleState` based on the presence of kings and rooks in their initial positions.
    - Parse the en passant target square, updating `b->epTarget` or setting it to `SQ_INVALID` if not applicable.
    - Parse the half move clock and full move count using `sscanf` and update `b->halfMoveClock` and `b->moveNumber`.
- **Output**: Returns 0 on successful initialization, or 1 if an error occurs in parsing the FEN string.
- **Functions Called**:
    - [`sqI`](<square.c.md#sqi>)
    - [`boardSetPiece`](<#boardsetpiece>)
    - [`boardGetPiece`](<#boardgetpiece>)
    - [`sqS`](<square.c.md#sqs>)


---
### boardSetPiece<!-- {{#callable:boardSetPiece}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L246>)

Sets a chess piece on a specified square of the board.
- **Inputs**:
    - `b`: A pointer to the `board` structure where the piece will be set.
    - `s`: The `sq` (square) structure representing the position on the board where the piece will be placed.
    - `p`: The `piece` to be placed on the specified square.
- **Logic and Control Flow**:
    - Calculate the index of the square `s` using the [`sqGetIndex`](<square.c.md#sqgetindex>) function.
    - Assign the piece `p` to the calculated index in the `pieces` array of the board `b`.
- **Output**: No output is returned as the function modifies the board in place.
- **Functions Called**:
    - [`sqGetIndex`](<square.c.md#sqgetindex>)


---
### boardGetPiece<!-- {{#callable:boardGetPiece}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L252>)

Retrieves the chess piece located at a specific square on the board.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chessboard.
    - `s`: The `sq` type representing the square on the board from which to retrieve the piece.
- **Logic and Control Flow**:
    - Call the function [`sqGetIndex`](<square.c.md#sqgetindex>) with the square `s` to get the index of the square on the board.
    - Access the `pieces` array in the `board` structure `b` using the calculated index.
    - Return the piece located at the specified index.
- **Output**: Returns the `piece` located at the specified square on the board.
- **Functions Called**:
    - [`sqGetIndex`](<square.c.md#sqgetindex>)


---
### boardGenerateMoves<!-- {{#callable:boardGenerateMoves}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L259>)

Generates a list of all legal moves for the current player on a chess board, including castling moves.
- **Inputs**:
    - `b`: A pointer to a `board` structure representing the current state of the chess game.
- **Logic and Control Flow**:
    - Create an empty `moveList` to store legal moves.
    - Iterate over each square on the board (64 squares total).
    - For each square, get the piece and check if it belongs to the current player.
    - Determine the type of piece and generate possible moves using the appropriate function for that piece type.
    - For each generated move, simulate the move on a copy of the board and check if the current player is not in check after the move.
    - If the move is legal (does not leave the player in check), add it to the `moveList`.
    - Check if castling is possible for the current player by verifying the conditions for castling moves (both kingside and queenside).
    - Add legal castling moves to the `moveList` if conditions are met.
    - Return the `moveList` containing all legal moves.
- **Output**: A pointer to a `moveList` structure containing all legal moves for the current player, which must be freed after use.
- **Functions Called**:
    - [`moveListCreate`](<movelist.c.md#movelistcreate>)
    - [`sqIndex`](<square.c.md#sqindex>)
    - [`boardGetPiece`](<#boardgetpiece>)
    - [`pieceGetColor`](<piece.c.md#piecegetcolor>)
    - [`pieceGetType`](<piece.c.md#piecegettype>)
    - [`pmGetPawnMoves`](<piecemoves.c.md#pmgetpawnmoves>)
    - [`pmGetKnightMoves`](<piecemoves.c.md#pmgetknightmoves>)
    - [`pmGetBishopMoves`](<piecemoves.c.md#pmgetbishopmoves>)
    - [`pmGetRookMoves`](<piecemoves.c.md#pmgetrookmoves>)
    - [`pmGetQueenMoves`](<piecemoves.c.md#pmgetqueenmoves>)
    - [`pmGetKingMoves`](<piecemoves.c.md#pmgetkingmoves>)
    - [`boardPlayMoveInPlace`](<#boardplaymoveinplace>)
    - [`boardIsPlayerInCheck`](<#boardisplayerincheck>)
    - [`moveListAdd`](<movelist.c.md#movelistadd>)
    - [`moveListFree`](<movelist.c.md#movelistfree>)
    - [`sqI`](<square.c.md#sqi>)
    - [`boardIsSquareAttacked`](<#boardissquareattacked>)
    - [`moveSq`](<move.c.md#movesq>)


---
### boardIsSquareAttacked<!-- {{#callable:boardIsSquareAttacked}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L361>)

Checks if a specific square on a chess board is attacked by any piece of a given color.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chess board.
    - `s`: The `sq` structure representing the square to check for an attack.
    - `attacker`: The `pieceColor` enumeration value representing the color of the attacking pieces to check against.
- **Logic and Control Flow**:
    - Iterates over all 64 squares on the board to find pieces of the specified attacker color.
    - For each piece found, determines its type and retrieves its possible attack moves using the appropriate function for that piece type.
    - Checks if any of the possible moves for the piece attack the specified square `s`.
    - If a move attacks the square, returns 1 indicating the square is attacked.
    - If no attacking move is found after checking all pieces, returns 0 indicating the square is not attacked.
- **Output**: Returns `1` if the square is attacked by a piece of the specified color, otherwise returns `0`.
- **Functions Called**:
    - [`sqIndex`](<square.c.md#sqindex>)
    - [`boardGetPiece`](<#boardgetpiece>)
    - [`pieceGetColor`](<piece.c.md#piecegetcolor>)
    - [`pieceGetType`](<piece.c.md#piecegettype>)
    - [`pmGetPawnAttacks`](<piecemoves.c.md#pmgetpawnattacks>)
    - [`pmGetKnightMoves`](<piecemoves.c.md#pmgetknightmoves>)
    - [`pmGetBishopMoves`](<piecemoves.c.md#pmgetbishopmoves>)
    - [`pmGetRookMoves`](<piecemoves.c.md#pmgetrookmoves>)
    - [`pmGetQueenMoves`](<piecemoves.c.md#pmgetqueenmoves>)
    - [`pmGetKingMoves`](<piecemoves.c.md#pmgetkingmoves>)
    - [`sqEq`](<square.c.md#sqeq>)
    - [`moveListFree`](<movelist.c.md#movelistfree>)


---
### boardIsInCheck<!-- {{#callable:boardIsInCheck}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L425>)

Checks if the current player on the board is in check.
- **Inputs**:
    - `b`: A pointer to a `board` structure representing the current state of the chess game.
- **Logic and Control Flow**:
    - Calls the function [`boardIsPlayerInCheck`](<#boardisplayerincheck>) with the board `b` and the current player `b->currentPlayer` as arguments.
    - Returns the result of [`boardIsPlayerInCheck`](<#boardisplayerincheck>), which indicates if the current player is in check.
- **Output**: Returns a `uint8_t` value, where `1` indicates the current player is in check, and `0` indicates they are not.
- **Functions Called**:
    - [`boardIsPlayerInCheck`](<#boardisplayerincheck>)


---
### boardIsPlayerInCheck<!-- {{#callable:boardIsPlayerInCheck}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L430>)

Checks if the specified player's king is in check on the given board.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chessboard.
    - `player`: The `pieceColor` enumeration value representing the player whose king is being checked (either `pcWhite` or `pcBlack`).
- **Logic and Control Flow**:
    - Determine the `royalPiece` as the king piece of the specified player (`pWKing` for white, `pBKing` for black).
    - Determine the `otherColor` as the opposite color of the specified player (`pcBlack` for white, `pcWhite` for black).
    - Iterate over all 64 squares of the board using a loop.
    - For each square, check if the piece on the square is the `royalPiece`.
    - If the `royalPiece` is found, check if the square is attacked by the `otherColor` using [`boardIsSquareAttacked`](<#boardissquareattacked>).
    - If the square is attacked, return 1 indicating the player is in check.
    - If no square with the `royalPiece` is attacked, return 0 indicating the player is not in check.
- **Output**: Returns `1` if the player's king is in check, otherwise returns `0`.
- **Functions Called**:
    - [`sqIndex`](<square.c.md#sqindex>)
    - [`boardGetPiece`](<#boardgetpiece>)
    - [`boardIsSquareAttacked`](<#boardissquareattacked>)


---
### boardIsInsufficientMaterial<!-- {{#callable:boardIsInsufficientMaterial}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L446>)

Determines if a chess board position has insufficient material to checkmate, resulting in a draw.
- **Inputs**:
    - `b`: A pointer to a `board` structure representing the current state of the chess board.
- **Logic and Control Flow**:
    - Initialize counters for pieces, knights, bishops on dark squares, bishops on light squares, and kings for both colors.
    - Iterate over all 64 squares of the board to count the number of each type of piece.
    - If only kings are present, return 1 indicating a draw due to insufficient material.
    - If there is one white king and one black king, check for the presence of only minor pieces (knights and bishops).
    - If there are only two kings and one minor piece, return 1 indicating a draw.
    - If there are only two kings and bishops all on the same color, return 1 indicating a draw.
    - If none of the conditions for insufficient material are met, return 0.
- **Output**: Returns `1` if the board position is a draw due to insufficient material, otherwise returns `0`.
- **Functions Called**:
    - [`sqIndex`](<square.c.md#sqindex>)
    - [`boardGetPiece`](<#boardgetpiece>)
    - [`pieceGetType`](<piece.c.md#piecegettype>)
    - [`sqIsDark`](<square.c.md#sqisdark>)


---
### boardPlayMove<!-- {{#callable:boardPlayMove}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L509>)

Creates a new board by copying an existing board and applying a move to it.
- **Inputs**:
    - ``b``: A pointer to the existing `board` structure that represents the current state of the chess game.
    - ``m``: A `move` structure that represents the move to be applied to the board.
- **Logic and Control Flow**:
    - Allocate memory for a new `board` structure and assign it to `newBoard`.
    - Copy the contents of the existing board `b` into `newBoard` using `memcpy`.
    - Call [`boardPlayMoveInPlace`](<#boardplaymoveinplace>) to apply the move `m` to `newBoard`.
    - Return the pointer to the newly created `newBoard`.
- **Output**: A pointer to a new `board` structure that represents the state of the board after the move `m` has been applied.
- **Functions Called**:
    - [`boardPlayMoveInPlace`](<#boardplaymoveinplace>)


---
### boardPlayMoveInPlace<!-- {{#callable:boardPlayMoveInPlace}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L521>)

Updates the board state by executing a given move, handling special cases like castling, en passant, and pawn promotion.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chess game.
    - `m`: A `move` structure representing the move to be played on the board.
- **Logic and Control Flow**:
    - If the current player is black, increment the move number.
    - Determine the piece type at the move's starting square and update the half-move clock based on the move's reversibility.
    - Check if the move is a castling move and update the board and castling rights accordingly.
    - If a rook moves or is captured, update the castling rights.
    - Handle en passant captures by removing the captured pawn from the board.
    - Move the piece from the starting square to the destination square, handling pawn promotion if applicable.
    - Set the en passant target square if a pawn moves two squares forward, otherwise invalidate it.
    - Switch the current player to the other player.
- **Output**: The function does not return a value; it modifies the board state in place.
- **Functions Called**:
    - [`pieceGetType`](<piece.c.md#piecegettype>)
    - [`boardGetPiece`](<#boardgetpiece>)
    - [`boardSetPiece`](<#boardsetpiece>)
    - [`sqI`](<square.c.md#sqi>)
    - [`sqEq`](<square.c.md#sqeq>)
    - [`pieceMake`](<piece.c.md#piecemake>)


---
### boardEq<!-- {{#callable:boardEq}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L607>)

Compares two chess boards to determine if they are fully equal.
- **Inputs**:
    - `b1`: Pointer to the first `board` structure to compare.
    - `b2`: Pointer to the second `board` structure to compare.
- **Logic and Control Flow**:
    - Check if `currentPlayer` of `b1` and `b2` are different; if so, return 0.
    - Check if `castleState` of `b1` and `b2` are different; if so, return 0.
    - Use [`sqEq`](<square.c.md#sqeq>) to compare `epTarget` of `b1` and `b2`; if they are not equal, return 0.
    - Check if `halfMoveClock` of `b1` and `b2` are different; if so, return 0.
    - Check if `moveNumber` of `b1` and `b2` are different; if so, return 0.
    - Use `memcmp` to compare the memory of `b1` and `b2` for 64 pieces; if they differ, return 0.
    - If all checks pass, return 1.
- **Output**: Returns `1` if the boards are fully equal, otherwise returns `0`.
- **Functions Called**:
    - [`sqEq`](<square.c.md#sqeq>)


---
### boardEqContext<!-- {{#callable:boardEqContext}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L631>)

Checks if two chess boards are contextually equal by comparing player turn, castling rights, piece positions, and valid en passant targets.
- **Inputs**:
    - `b1`: Pointer to the first `board` structure to compare.
    - `b2`: Pointer to the second `board` structure to compare.
- **Logic and Control Flow**:
    - Check if the current player on `b1` is the same as on `b2`; if not, return 0.
    - Check if the castling state on `b1` is the same as on `b2`; if not, return 0.
    - Compare the memory of `b1` and `b2` for the first 64 pieces; if they differ, return 0.
    - Filter the en passant target square for `b1` by checking if any pawns can attack it; if not, set it to `SQ_INVALID`.
    - Filter the en passant target square for `b2` by checking if any pawns can attack it; if not, set it to `SQ_INVALID`.
    - Compare the filtered en passant target squares of `b1` and `b2`; if they differ, return 0.
    - If all checks pass, return 1.
- **Output**: Returns `1` if the boards are contextually equal, otherwise returns `0`.
- **Functions Called**:
    - [`sqEq`](<square.c.md#sqeq>)
    - [`sqI`](<square.c.md#sqi>)
    - [`boardGetPiece`](<#boardgetpiece>)
    - [`boardPlayMoveInPlace`](<#boardplaymoveinplace>)
    - [`moveSq`](<move.c.md#movesq>)
    - [`boardIsPlayerInCheck`](<#boardisplayerincheck>)


---
### boardGetFen<!-- {{#callable:boardGetFen}} -->
[View Source →](<../../../../../chesslib/src/chesslib/board.c#L716>)

Generates a FEN string representation of the current state of a chess board.
- **Inputs**:
    - `b`: A pointer to a `board` structure representing the current state of the chess game.
- **Logic and Control Flow**:
    - Initialize a buffer `buf` to store the FEN string and a pointer `c` to traverse the buffer.
    - Iterate over each rank from 8 to 1 and each file from 1 to 8 to process the board pieces.
    - For each square, check if a piece is present; if so, append its letter to the buffer, otherwise count blank squares.
    - After processing a rank, append the count of blank squares if any, and add a '/' if not the last rank.
    - Append the current player's turn ('w' for white, 'b' for black) to the buffer.
    - Append the castling availability using 'K', 'Q', 'k', 'q', or '-' if no castling is possible.
    - Append the en passant target square or '-' if there is none.
    - Use `sprintf` to append the half move clock and move number to the buffer.
    - Allocate memory for the FEN string, copy the buffer content to it, and return the FEN string.
- **Output**: A dynamically allocated string containing the FEN representation of the board, which must be freed by the caller.
- **Functions Called**:
    - [`sqI`](<square.c.md#sqi>)
    - [`boardGetPiece`](<#boardgetpiece>)
    - [`pieceGetLetter`](<piece.c.md#piecegetletter>)
    - [`sqEq`](<square.c.md#sqeq>)
    - [`sqGetStr`](<square.c.md#sqgetstr>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)