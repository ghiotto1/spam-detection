<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements chess piece movement logic, including specific move generation for each piece type.

# Purpose
The code defines functions to calculate possible moves for chess pieces on a board. It includes functions for different types of chess pieces such as pawns, knights, bishops, rooks, queens, and kings. Each function generates a list of valid moves for a given piece type from a specified position on the board. The code uses helper functions like [`canMoveHere`](<#canmovehere>) to determine if a piece can move to a specific square, considering the presence of other pieces and their colors.

The code is part of a chess library, as indicated by the inclusion of the header file `chesslib/piecemoves.h`. It provides specific functionality for determining the movement of chess pieces, which can be used in a larger chess game application. The functions [`pmLeaperMoveList`](<#pmleapermovelist>) and [`pmRiderMoveList`](<#pmridermovelist>) are used to handle the movement logic for leaping and riding pieces, respectively. The code also includes special handling for pawn movements, including promotions and en passant captures. The movement logic is encapsulated in functions that return a `moveList`, which represents the possible moves for a piece from a given position.
# Imports and Dependencies

---
- `chesslib/piecemoves.h`


# Global Variables

---
### knightOffsets
- **Type**: `int8_t`
- **Description**: Defines the possible move offsets for a knight piece in a chess game. Each pair of integers in the array represents a possible move direction for the knight on a chessboard.
- **Use**: Used in the `pmGetKnightMoves` function to generate a list of valid moves for a knight piece.


---
### bishopOffsets
- **Type**: `int8_t`
- **Description**: Defines the possible movement directions for a bishop in a chess game. Each pair of integers in the array represents a direction on the chessboard, with the first integer indicating the change in file and the second integer indicating the change in rank.
- **Use**: Used in the `pmGetBishopMoves` function to calculate all possible moves for a bishop piece on the board.


---
### rookOffsets
- **Type**: `int8_t[4][2]`
- **Description**: Defines the directional offsets for a rook's movement on a chessboard. Each pair of integers represents a possible direction the rook can move: vertically or horizontally.
- **Use**: Used in the `pmGetRookMoves` function to calculate all possible moves for a rook on the board.


---
### royalOffsets
- **Type**: `int8_t`
- **Description**: `royalOffsets` is a two-dimensional array of type `int8_t` with dimensions 8x2. It contains pairs of integers that represent the possible movement directions for chess pieces that can move one square in any direction, such as the king and queen.
- **Use**: Used to define the movement directions for the king and queen in chess, allowing them to move one square in any of the eight possible directions on the board.


# Functions

---
### canMoveHere<!-- {{#callable:canMoveHere}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L15>)

Determines if a move to a specified square is possible based on the presence and color of a piece on that square.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chessboard.
    - `s`: The `sq` structure representing the target square on the board.
    - `ourColor`: The `pieceColor` enumeration value representing the color of the piece attempting to move.
- **Logic and Control Flow**:
    - Retrieve the piece located at square `s` on the board `b` using [`boardGetPiece`](<board.c.md#boardgetpiece>) function.
    - Check if the retrieved piece is `pEmpty`, indicating the square is empty; if so, return 1 (true).
    - If the square is not empty, get the color of the piece using [`pieceGetColor`](<piece.c.md#piecegetcolor>).
    - Compare `ourColor` with the color of the piece on the square; return 1 (true) if they are different, otherwise return 0 (false).
- **Output**: Returns an integer value: 1 if the move is possible (the square is empty or occupied by an opponent's piece), or 0 if the square is occupied by a piece of the same color.
- **Functions Called**:
    - [`boardGetPiece`](<board.c.md#boardgetpiece>)
    - [`pieceGetColor`](<piece.c.md#piecegetcolor>)


---
### pmLeaperMoveList<!-- {{#callable:pmLeaperMoveList}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L26>)

Generates a list of valid moves for a leaper piece from a given position on a chess board.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chess board.
    - `s`: The `sq` structure representing the current position of the piece on the board.
    - `pt`: The `pieceType` enumeration value representing the type of the piece to move.
    - `dirs`: A 2D array of integers representing the possible movement directions for the piece.
    - `numDirs`: The number of movement directions provided in the `dirs` array.
- **Logic and Control Flow**:
    - Create a new `moveList` to store possible moves.
    - Retrieve the piece at the given square `s` on the board `b`.
    - Check if the piece type matches the specified `pieceType` `pt`; if not, return the empty move list.
    - Get the color of the piece to determine valid moves.
    - Iterate over each direction in the `dirs` array.
    - Calculate the new square by adding the direction offsets to the current square `s`.
    - Check if the new square is within the bounds of the board (1 to 8 for both file and rank).
    - If the new square is valid and can be moved to (no same-color piece), add the move to the `moveList`.
    - Return the populated `moveList` with all valid moves.
- **Output**: A pointer to a `moveList` structure containing all valid moves for the leaper piece from the given position.
- **Functions Called**:
    - [`moveListCreate`](<movelist.c.md#movelistcreate>)
    - [`boardGetPiece`](<board.c.md#boardgetpiece>)
    - [`pieceGetType`](<piece.c.md#piecegettype>)
    - [`pieceGetColor`](<piece.c.md#piecegetcolor>)
    - [`canMoveHere`](<#canmovehere>)
    - [`moveListAdd`](<movelist.c.md#movelistadd>)
    - [`moveSq`](<move.c.md#movesq>)


---
### pmRiderMoveList<!-- {{#callable:pmRiderMoveList}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L52>)

Generates a list of valid moves for a rider-type chess piece from a given position on the board.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chessboard.
    - `s`: The `sq` structure representing the current square of the piece on the board.
    - `pt`: The `pieceType` enumeration value representing the type of the piece (e.g., bishop, rook, queen).
    - `dirs`: A 2D array of integers representing the possible movement directions for the piece.
    - `numDirs`: The number of directions available in the `dirs` array.
- **Logic and Control Flow**:
    - Create a new `moveList` to store possible moves.
    - Retrieve the piece at the given square `s` on the board `b`.
    - Check if the piece type matches the specified `pt`; if not, return the empty move list.
    - Determine the color of the piece to ensure moves do not capture pieces of the same color.
    - Iterate over each direction in `dirs` to explore possible moves.
    - For each direction, repeatedly move the piece in that direction until it reaches the edge of the board or encounters another piece.
    - If the new square is within board boundaries, check if the piece can move there using [`canMoveHere`](<#canmovehere>).
    - Add the move to the list if it is valid.
    - Stop further movement in a direction if a piece is encountered (capturing is possible but cannot move past it).
    - Return the list of valid moves.
- **Output**: A pointer to a `moveList` containing all valid moves for the piece from the given square.
- **Functions Called**:
    - [`moveListCreate`](<movelist.c.md#movelistcreate>)
    - [`boardGetPiece`](<board.c.md#boardgetpiece>)
    - [`pieceGetType`](<piece.c.md#piecegettype>)
    - [`pieceGetColor`](<piece.c.md#piecegetcolor>)
    - [`canMoveHere`](<#canmovehere>)
    - [`moveListAdd`](<movelist.c.md#movelistadd>)
    - [`moveSq`](<move.c.md#movesq>)


---
### addPawnMoveToMoveList<!-- {{#callable:addPawnMoveToMoveList}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L95>)

Adds a pawn move to a move list, including promotion moves if applicable.
- **Inputs**:
    - ``list``: A pointer to a `moveList` where the pawn move will be added.
    - ``oldSq``: The starting square of the pawn.
    - ``newSq``: The destination square of the pawn.
- **Logic and Control Flow**:
    - Check if the destination square `newSq` is on the first or eighth rank, indicating a promotion opportunity.
    - If a promotion is possible, add moves to the list for promoting the pawn to a queen, rook, bishop, and knight.
    - If no promotion is possible, add a regular pawn move from `oldSq` to `newSq` to the list.
- **Output**: No return value; the function modifies the `moveList` pointed to by `list`.
- **Functions Called**:
    - [`moveListAdd`](<movelist.c.md#movelistadd>)
    - [`movePromote`](<move.c.md#movepromote>)
    - [`moveSq`](<move.c.md#movesq>)


---
### pmGetPawnMoves<!-- {{#callable:pmGetPawnMoves}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L111>)

Generates a list of all possible legal moves for a pawn located at a given square on a chess board.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chess board.
    - `s`: The `sq` structure representing the current position of the pawn on the board.
- **Logic and Control Flow**:
    - Create an empty move list using `moveListCreate()`.
    - Retrieve the piece at square `s` using `boardGetPiece(b, s)` and check if it is a pawn using `pieceGetType(p)`. If not, return the empty move list.
    - Determine the pawn's color using `pieceGetColor(p)` and set `delta` to 1 for white pawns and -1 for black pawns.
    - Calculate the square directly in front of the pawn (`newSq`) and check if it is empty using `boardGetPiece(b, newSq)`. If empty, add the move to the list using `addPawnMoveToMoveList(list, s, newSq)`.
    - Check if the pawn can move two squares forward (if it is on its starting rank) and if the square two ranks ahead is empty, add that move to the list.
    - For captures, check the diagonally adjacent squares (`s.file - 1` and `s.file + 1`) for opponent pieces or en passant targets and add those moves to the list if valid.
    - Return the populated move list.
- **Output**: A pointer to a `moveList` structure containing all legal moves for the pawn at the given square.
- **Functions Called**:
    - [`moveListCreate`](<movelist.c.md#movelistcreate>)
    - [`boardGetPiece`](<board.c.md#boardgetpiece>)
    - [`pieceGetType`](<piece.c.md#piecegettype>)
    - [`pieceGetColor`](<piece.c.md#piecegetcolor>)
    - [`sqI`](<square.c.md#sqi>)
    - [`addPawnMoveToMoveList`](<#addpawnmovetomovelist>)
    - [`canMoveHere`](<#canmovehere>)
    - [`sqEq`](<square.c.md#sqeq>)


---
### pmGetPawnAttacks<!-- {{#callable:pmGetPawnAttacks}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L162>)

Determines potential attack squares for a pawn on a chessboard.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chessboard.
    - `s`: The `sq` structure representing the current position of the pawn on the board.
- **Logic and Control Flow**:
    - Create a new `moveList` to store potential attack moves.
    - Retrieve the piece at the given square `s` using [`boardGetPiece`](<board.c.md#boardgetpiece>) and check if it is a pawn using [`pieceGetType`](<piece.c.md#piecegettype>).
    - If the piece is not a pawn, return the empty `moveList`.
    - Determine the pawn's color using [`pieceGetColor`](<piece.c.md#piecegetcolor>) and set `delta` to 1 for white pawns and -1 for black pawns.
    - Check if the pawn can attack to the left (file > 1) by calculating the new square and using [`canMoveHere`](<#canmovehere>) to verify if the move is possible, then add the move to the list if valid.
    - Check if the pawn can attack to the right (file < 8) by calculating the new square and using [`canMoveHere`](<#canmovehere>) to verify if the move is possible, then add the move to the list if valid.
    - Return the `moveList` containing all potential attack moves.
- **Output**: A pointer to a `moveList` containing potential attack moves for the pawn.
- **Functions Called**:
    - [`moveListCreate`](<movelist.c.md#movelistcreate>)
    - [`boardGetPiece`](<board.c.md#boardgetpiece>)
    - [`pieceGetType`](<piece.c.md#piecegettype>)
    - [`pieceGetColor`](<piece.c.md#piecegetcolor>)
    - [`sqI`](<square.c.md#sqi>)
    - [`canMoveHere`](<#canmovehere>)
    - [`moveListAdd`](<movelist.c.md#movelistadd>)
    - [`moveSq`](<move.c.md#movesq>)


---
### pmGetKnightMoves<!-- {{#callable:pmGetKnightMoves}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L197>)

Generates a list of all possible moves for a knight from a given position on a chessboard.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chessboard.
    - `s`: The `sq` structure representing the current position of the knight on the board.
- **Logic and Control Flow**:
    - Calls the [`pmLeaperMoveList`](<#pmleapermovelist>) function with the board, current square, piece type `ptKnight`, `knightOffsets` array, and the number of directions (8) as arguments.
    - The [`pmLeaperMoveList`](<#pmleapermovelist>) function generates and returns a list of valid moves for the knight based on its movement pattern.
- **Output**: A pointer to a `moveList` structure containing all valid moves for the knight from the given position.
- **Functions Called**:
    - [`pmLeaperMoveList`](<#pmleapermovelist>)


---
### pmGetBishopMoves<!-- {{#callable:pmGetBishopMoves}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L209>)

Generates a list of all possible moves for a bishop on a chessboard from a given position.
- **Inputs**:
    - ``b``: A pointer to the `board` structure representing the current state of the chessboard.
    - ``s``: A `sq` structure representing the current position of the bishop on the board.
- **Logic and Control Flow**:
    - Calls the [`pmRiderMoveList`](<#pmridermovelist>) function with the board, position, piece type `ptBishop`, direction offsets `bishopOffsets`, and the number of directions `4`.
    - The [`pmRiderMoveList`](<#pmridermovelist>) function calculates all possible moves for the bishop by iterating over the diagonal directions specified in `bishopOffsets`.
- **Output**: Returns a pointer to a `moveList` structure containing all valid moves for the bishop from the given position.
- **Functions Called**:
    - [`pmRiderMoveList`](<#pmridermovelist>)


---
### pmGetRookMoves<!-- {{#callable:pmGetRookMoves}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L221>)

Generates a list of all possible moves for a rook on a given chessboard from a specified square.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chessboard.
    - `s`: The `sq` structure representing the current position of the rook on the board.
- **Logic and Control Flow**:
    - Calls the [`pmRiderMoveList`](<#pmridermovelist>) function with the board, square, piece type `ptRook`, direction offsets `rookOffsets`, and the number of directions `4`.
- **Output**: Returns a pointer to a `moveList` structure containing all valid moves for the rook from the specified square.
- **Functions Called**:
    - [`pmRiderMoveList`](<#pmridermovelist>)


---
### pmGetQueenMoves<!-- {{#callable:pmGetQueenMoves}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L233>)

Generates a list of all possible moves for a queen on a chessboard from a given position.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chessboard.
    - `s`: The `sq` structure representing the current position of the queen on the board.
- **Logic and Control Flow**:
    - Calls the [`pmRiderMoveList`](<#pmridermovelist>) function with the board, position, piece type `ptQueen`, direction offsets `royalOffsets`, and number of directions `8`.
    - The [`pmRiderMoveList`](<#pmridermovelist>) function generates moves for pieces that can move any number of squares in a given direction, like the queen.
- **Output**: Returns a pointer to a `moveList` structure containing all valid moves for the queen from the specified position.
- **Functions Called**:
    - [`pmRiderMoveList`](<#pmridermovelist>)


---
### pmGetKingMoves<!-- {{#callable:pmGetKingMoves}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L243>)

Generates a list of all possible legal moves for a king piece from a given position on a chess board.
- **Inputs**:
    - ``b``: A pointer to the `board` structure representing the current state of the chess board.
    - ``s``: A `sq` structure representing the current position of the king on the board.
- **Logic and Control Flow**:
    - Calls the [`pmLeaperMoveList`](<#pmleapermovelist>) function with the board, position, piece type `ptKing`, direction offsets `royalOffsets`, and number of directions `8`.
    - The [`pmLeaperMoveList`](<#pmleapermovelist>) function calculates all possible moves for the king based on the given offsets and returns a list of these moves.
- **Output**: A pointer to a `moveList` structure containing all possible legal moves for the king from the given position.
- **Functions Called**:
    - [`pmLeaperMoveList`](<#pmleapermovelist>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)