<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements chess piece movement logic, including pawn promotions and special moves, to avoid circular dependencies.

# Purpose
The code defines functions for determining the possible moves of chess pieces on a chessboard. It includes functions for each type of chess piece: pawns, knights, bishops, rooks, queens, and kings. The code uses helper functions such as [`canMoveHere`](<#canmovehere>) to check if a piece can move to a specific square without encountering a piece of the same color. The functions [`pmLeaperMoveList`](<#pmleapermovelist>) and [`pmRiderMoveList`](<#pmridermovelist>) are used to generate move lists for pieces that move in fixed patterns (leapers) and those that can move multiple squares in a direction (riders), respectively.

The code is part of a chess library, as indicated by the inclusion of the header file `chesslib/piecemoves.h`. It provides specific functionality for generating move lists for each piece type, which can be used in a chess game engine to determine legal moves. The functions return a `moveList`, which is a collection of possible moves for a given piece from a specific position on the board. The code handles special cases such as pawn promotion and en passant captures. The use of arrays to define movement offsets for each piece type allows for efficient calculation of potential moves.
# Imports and Dependencies

---
- `chesslib/piecemoves.h`


# Global Variables

---
### knightOffsets
- **Type**: `int8_t[8][2]`
- **Description**: Defines the possible move offsets for a knight in a chess game. Each pair of integers in the array represents a possible move direction for the knight on a chessboard, with the first integer indicating the change in file and the second integer indicating the change in rank.
- **Use**: Used to calculate the potential moves a knight can make from a given position on the chessboard.


---
### bishopOffsets
- **Type**: `int8_t`
- **Description**: Defines the possible movement directions for a bishop on a chessboard. Each pair of integers in the array represents a direction in which the bishop can move diagonally.
- **Use**: Used in the `pmGetBishopMoves` function to determine the valid moves for a bishop piece.


---
### rookOffsets
- **Type**: `int8_t[4][2]`
- **Description**: Defines the possible movement directions for a rook in a chess game. Each sub-array represents a direction in which the rook can move on the chessboard.
- **Use**: Used in the `pmGetRookMoves` function to determine the valid moves for a rook piece.


---
### royalOffsets
- **Type**: `int8_t`
- **Description**: `royalOffsets` is a two-dimensional array of type `int8_t` with dimensions 8x2. It contains pairs of integers that represent the possible movement directions for chess pieces that can move one square in any direction, such as the king and queen.
- **Use**: Used to determine the movement directions for the king and queen in chess.


# Functions

---
### canMoveHere<!-- {{#callable:canMoveHere}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L15>)

Determines if a move to a specified square is possible based on the presence and color of a piece on that square.
- **Inputs**:
    - ``b``: A pointer to the `board` structure representing the current state of the chessboard.
    - ``s``: The `sq` structure representing the target square on the board.
    - ``ourColor``: The `pieceColor` enumeration value representing the color of the piece attempting to move.
- **Logic and Control Flow**:
    - Retrieve the piece located at square `s` on the board `b` using [`boardGetPiece`](<board.c.md#boardgetpiece>) function.
    - Check if the retrieved piece is `pEmpty` (indicating the square is empty).
    - If the square is empty, return 1 (true), indicating the move is possible.
    - If the square is not empty, get the color of the piece using [`pieceGetColor`](<piece.c.md#piecegetcolor>).
    - Compare the color of the piece on the square with `ourColor`.
    - Return 1 (true) if the colors are different, indicating the move is possible; otherwise, return 0 (false).
- **Output**: Returns an integer value: 1 if the move is possible (either the square is empty or occupied by an opponent's piece), or 0 if the square is occupied by a piece of the same color.
- **Functions Called**:
    - [`boardGetPiece`](<board.c.md#boardgetpiece>)
    - [`pieceGetColor`](<piece.c.md#piecegetcolor>)


---
### pmLeaperMoveList<!-- {{#callable:pmLeaperMoveList}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L26>)

Generates a list of valid moves for a leaper piece from a given position on a chess board.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chess board.
    - `s`: The `sq` structure representing the current position of the piece on the board.
    - `pt`: The `pieceType` indicating the type of the piece for which moves are being generated.
    - `dirs`: A 2D array of integers representing the possible directions the piece can move.
    - `numDirs`: The number of directions available in the `dirs` array.
- **Logic and Control Flow**:
    - Create a new `moveList` to store possible moves.
    - Retrieve the piece at the given square `s` on the board `b`.
    - Check if the piece type matches the specified `pieceType` `pt`; if not, return the empty move list.
    - Determine the color of the piece at the square `s`.
    - Iterate over each direction in the `dirs` array.
    - Calculate the new square by adding the direction offsets to the current square `s`.
    - Check if the new square is within the bounds of the board (1 to 8 for both file and rank).
    - If the new square is valid and can be moved to (no same-color piece), add the move to the `moveList`.
    - Return the `moveList` containing all valid moves.
- **Output**: A pointer to a `moveList` containing all valid moves for the leaper piece from the given position.
- **Functions Called**:
    - [`moveListCreate`](<movelist.c.md#movelistcreate>)
    - [`boardGetPiece`](<board.c.md#boardgetpiece>)
    - [`pieceGetType`](<piece.c.md#piecegettype>)
    - [`pieceGetColor`](<piece.c.md#piecegetcolor>)
    - [`canMoveHere`](<#canmovehere>)
    - [`moveListAdd`](<movelist.c.md#movelistadd>)
    - [`moveSq`](<move.c.md#movesq>)


---
### pmRiderMoveList<!-- {{#callable:pmRiderMoveList}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L52>)

Generates a list of valid moves for a rider-type chess piece from a given position on the board.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chessboard.
    - `s`: The `sq` structure representing the current position of the piece on the board.
    - `pt`: The `pieceType` enumeration value representing the type of the piece (e.g., bishop, rook, queen).
    - `dirs`: A 2D array of integers representing the possible movement directions for the piece.
    - `numDirs`: The number of directions in the `dirs` array.
- **Logic and Control Flow**:
    - Create a new `moveList` to store possible moves.
    - Retrieve the piece at the given square `s` on the board `b`.
    - Check if the piece type matches the specified `pieceType` `pt`; if not, return the empty move list.
    - Determine the color of the piece to ensure moves do not capture pieces of the same color.
    - Iterate over each direction in the `dirs` array.
    - For each direction, repeatedly move the piece in that direction until it goes off the board or encounters another piece.
    - If the new position is within the board and does not contain a piece of the same color, add the move to the list.
    - Stop further movement in a direction if a piece is encountered, as riders cannot jump over pieces.
    - Return the list of valid moves.
- **Output**: A pointer to a `moveList` containing all valid moves for the piece from the given position.
- **Functions Called**:
    - [`moveListCreate`](<movelist.c.md#movelistcreate>)
    - [`boardGetPiece`](<board.c.md#boardgetpiece>)
    - [`pieceGetType`](<piece.c.md#piecegettype>)
    - [`pieceGetColor`](<piece.c.md#piecegetcolor>)
    - [`canMoveHere`](<#canmovehere>)
    - [`moveListAdd`](<movelist.c.md#movelistadd>)
    - [`moveSq`](<move.c.md#movesq>)


---
### addPawnMoveToMoveList<!-- {{#callable:addPawnMoveToMoveList}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L95>)

Adds a pawn move to the move list, including promotion moves if applicable.
- **Inputs**:
    - ``list``: A pointer to a `moveList` structure where the move will be added.
    - ``oldSq``: The starting square of the pawn.
    - ``newSq``: The destination square of the pawn.
- **Logic and Control Flow**:
    - Check if the move results in a promotion by verifying if `newSq.rank` is 1 or 8.
    - If it is a promotion, add moves for promoting the pawn to a queen, rook, bishop, and knight to the move list using [`moveListAdd`](<movelist.c.md#movelistadd>) and [`movePromote`](<move.c.md#movepromote>).
    - If it is not a promotion, add a regular move from `oldSq` to `newSq` to the move list using [`moveListAdd`](<movelist.c.md#movelistadd>) and [`moveSq`](<move.c.md#movesq>).
- **Output**: No return value; the function modifies the `moveList` pointed to by `list`.
- **Functions Called**:
    - [`moveListAdd`](<movelist.c.md#movelistadd>)
    - [`movePromote`](<move.c.md#movepromote>)
    - [`moveSq`](<move.c.md#movesq>)


---
### pmGetPawnMoves<!-- {{#callable:pmGetPawnMoves}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L111>)

Generates a list of all possible legal moves for a pawn located at a given square on a chess board.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chess board.
    - `s`: The `sq` structure representing the current position of the pawn on the board.
- **Logic and Control Flow**:
    - Create an empty move list using `moveListCreate()`.
    - Retrieve the piece at square `s` using `boardGetPiece()` and check if it is a pawn; if not, return the empty move list.
    - Determine the pawn's color and set the movement direction (`delta`) based on the color (1 for white, -1 for black).
    - Calculate the square directly in front of the pawn and check if it is empty; if so, add this move to the list.
    - Check if the pawn is in its initial position and can move two squares forward; if so, add this move to the list if the path is clear.
    - For capture moves, check the diagonally adjacent squares for opponent pieces or en passant targets and add these moves to the list if valid.
    - Return the populated move list.
- **Output**: A pointer to a `moveList` structure containing all possible legal moves for the pawn at the given square.
- **Functions Called**:
    - [`moveListCreate`](<movelist.c.md#movelistcreate>)
    - [`boardGetPiece`](<board.c.md#boardgetpiece>)
    - [`pieceGetType`](<piece.c.md#piecegettype>)
    - [`pieceGetColor`](<piece.c.md#piecegetcolor>)
    - [`sqI`](<square.c.md#sqi>)
    - [`addPawnMoveToMoveList`](<#addpawnmovetomovelist>)
    - [`canMoveHere`](<#canmovehere>)
    - [`sqEq`](<square.c.md#sqeq>)


---
### pmGetPawnAttacks<!-- {{#callable:pmGetPawnAttacks}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L162>)

Determines potential attack squares for a pawn on a chessboard.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chessboard.
    - `s`: The `sq` structure representing the current position of the pawn on the board.
- **Logic and Control Flow**:
    - Create a new `moveList` to store potential attack moves.
    - Retrieve the piece at square `s` on the board `b`.
    - Check if the piece is a pawn; if not, return the empty `moveList`.
    - Determine the pawn's color and set `delta` to 1 for white or -1 for black to calculate rank movement direction.
    - Check if the pawn can attack to the left (file > 1) by creating a new square `newSq` and verifying if it is a valid move using [`canMoveHere`](<#canmovehere>).
    - If valid, add the move from `s` to `newSq` to the `moveList`.
    - Check if the pawn can attack to the right (file < 8) by creating a new square `newSq` and verifying if it is a valid move using [`canMoveHere`](<#canmovehere>).
    - If valid, add the move from `s` to `newSq` to the `moveList`.
    - Return the `moveList` containing all potential attack moves.
- **Output**: A pointer to a `moveList` containing potential attack moves for the pawn from its current position.
- **Functions Called**:
    - [`moveListCreate`](<movelist.c.md#movelistcreate>)
    - [`boardGetPiece`](<board.c.md#boardgetpiece>)
    - [`pieceGetType`](<piece.c.md#piecegettype>)
    - [`pieceGetColor`](<piece.c.md#piecegetcolor>)
    - [`sqI`](<square.c.md#sqi>)
    - [`canMoveHere`](<#canmovehere>)
    - [`moveListAdd`](<movelist.c.md#movelistadd>)
    - [`moveSq`](<move.c.md#movesq>)


---
### pmGetKnightMoves<!-- {{#callable:pmGetKnightMoves}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L197>)

Generates a list of all possible moves for a knight from a given position on a chessboard.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chessboard.
    - `s`: The `sq` structure representing the current position of the knight on the board.
- **Logic and Control Flow**:
    - Calls the [`pmLeaperMoveList`](<#pmleapermovelist>) function with the board, current square, piece type `ptKnight`, `knightOffsets` array, and the number of directions (8) as arguments.
    - The [`pmLeaperMoveList`](<#pmleapermovelist>) function processes the knight's movement logic using the provided offsets to determine valid moves.
- **Output**: Returns a pointer to a `moveList` structure containing all valid moves for the knight from the given position.
- **Functions Called**:
    - [`pmLeaperMoveList`](<#pmleapermovelist>)


---
### pmGetBishopMoves<!-- {{#callable:pmGetBishopMoves}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L209>)

Generates a list of all possible moves for a bishop on a chessboard from a given position.
- **Inputs**:
    - ``b``: A pointer to the `board` structure representing the current state of the chessboard.
    - ``s``: A `sq` structure representing the current position of the bishop on the board.
- **Logic and Control Flow**:
    - Calls the [`pmRiderMoveList`](<#pmridermovelist>) function with the board, position, piece type `ptBishop`, direction offsets `bishopOffsets`, and the number of directions `4`.
    - The [`pmRiderMoveList`](<#pmridermovelist>) function calculates all possible moves for the bishop by iterating over the direction offsets and checking each square in those directions until it reaches the edge of the board or another piece.
- **Output**: Returns a pointer to a `moveList` structure containing all valid moves for the bishop from the given position.
- **Functions Called**:
    - [`pmRiderMoveList`](<#pmridermovelist>)


---
### pmGetRookMoves<!-- {{#callable:pmGetRookMoves}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L221>)

Generates a list of all possible moves for a rook from a given position on a chessboard.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chessboard.
    - `s`: The `sq` structure representing the current position of the rook on the board.
- **Logic and Control Flow**:
    - Calls the [`pmRiderMoveList`](<#pmridermovelist>) function with the board `b`, position `s`, piece type `ptRook`, direction offsets `rookOffsets`, and number of directions `4`.
- **Output**: Returns a pointer to a `moveList` structure containing all valid moves for the rook from the given position.
- **Functions Called**:
    - [`pmRiderMoveList`](<#pmridermovelist>)


---
### pmGetQueenMoves<!-- {{#callable:pmGetQueenMoves}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L233>)

Generates a list of all possible moves for a queen on a chessboard from a given position.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chessboard.
    - `s`: A `sq` structure representing the current position of the queen on the board.
- **Logic and Control Flow**:
    - Calls the [`pmRiderMoveList`](<#pmridermovelist>) function with the board, position, piece type `ptQueen`, direction offsets `royalOffsets`, and number of directions `8`.
- **Output**: Returns a pointer to a `moveList` structure containing all possible moves for the queen from the given position.
- **Functions Called**:
    - [`pmRiderMoveList`](<#pmridermovelist>)


---
### pmGetKingMoves<!-- {{#callable:pmGetKingMoves}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L243>)

Generates a list of all possible moves for a king piece from a given square on a chess board.
- **Inputs**:
    - ``b``: A pointer to the `board` structure representing the current state of the chess board.
    - ``s``: The `sq` structure representing the current position of the king on the board.
- **Logic and Control Flow**:
    - Calls the [`pmLeaperMoveList`](<#pmleapermovelist>) function with the board, square, piece type `ptKing`, direction offsets `royalOffsets`, and number of directions `8`.
    - The [`pmLeaperMoveList`](<#pmleapermovelist>) function generates a list of valid moves for the king based on its leaping movement pattern.
- **Output**: Returns a pointer to a `moveList` structure containing all valid moves for the king from the specified square.
- **Functions Called**:
    - [`pmLeaperMoveList`](<#pmleapermovelist>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)