<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements chess piece movement logic, including specific move generation for each piece type.

# Purpose
The code defines functions for determining the possible moves of chess pieces on a chessboard. It includes functions for each type of chess piece: pawns, knights, bishops, rooks, queens, and kings. The functions calculate valid moves based on the current position of a piece, the type of piece, and the state of the board. The code uses helper functions such as [`canMoveHere`](<#canmovehere>) to check if a move is valid, considering the presence of other pieces and their colors. The code also handles special cases like pawn promotions and en passant captures.

The code is part of a chess library, as indicated by the inclusion of the header file `chesslib/piecemoves.h`. It provides specific functionality for generating move lists for different chess pieces, which can be used by other parts of a chess program to evaluate possible moves and game states. The functions return a `moveList`, which is a collection of possible moves for a given piece from a specific position. The code avoids circular dependencies by implementing these functions in a separate file rather than in `move.c`.
# Imports and Dependencies

---
- `chesslib/piecemoves.h`


# Global Variables

---
### knightOffsets
- **Type**: `int8_t[8][2]`
- **Description**: Defines the possible move offsets for a knight in a chess game. Each pair of integers represents a relative move in terms of file and rank on the chessboard.
- **Use**: Used in the `pmGetKnightMoves` function to generate possible moves for a knight.


---
### bishopOffsets
- **Type**: `int8_t[4][2]`
- **Description**: Defines the possible movement directions for a bishop in a chess game. Each pair of integers represents a direction on the chessboard: diagonal up-right, diagonal up-left, diagonal down-left, and diagonal down-right.
- **Use**: Used in the `pmGetBishopMoves` function to calculate all possible moves for a bishop on the board.


---
### rookOffsets
- **Type**: `int8_t[4][2]`
- **Description**: Defines the directional offsets for a rook's movement on a chessboard. Each pair of integers represents a possible direction the rook can move in terms of file and rank changes.
- **Use**: Used in the `pmGetRookMoves` function to determine all possible moves for a rook on the board.


---
### royalOffsets
- **Type**: `int8_t`
- **Description**: An 8x2 array of signed 8-bit integers that represents the possible movement offsets for the queen and king pieces in a chess game. Each pair of integers in the array corresponds to a direction in which these pieces can move on the chessboard.
- **Use**: Used to determine the movement directions for the queen and king pieces in the `pmGetQueenMoves` and `pmGetKingMoves` functions.


# Functions

---
### canMoveHere<!-- {{#callable:canMoveHere}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L15>)

Determines if a move to a specified square is possible based on the presence and color of a piece on that square.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chessboard.
    - `s`: The `sq` structure representing the target square on the board.
    - `ourColor`: The `pieceColor` enumeration value representing the color of the piece attempting to move.
- **Logic and Control Flow**:
    - Retrieve the piece located at square `s` on the board `b` using [`boardGetPiece`](<board.c.md#boardgetpiece>) function.
    - Check if the retrieved piece is `pEmpty`, indicating the square is empty; if so, return 1 (true).
    - If the square is not empty, get the color of the piece using [`pieceGetColor`](<piece.c.md#piecegetcolor>).
    - Compare the color of the piece on the square with `ourColor`.
    - Return 1 (true) if the colors are different, indicating the move is possible; otherwise, return 0 (false).
- **Output**: Returns an integer value: 1 if the move is possible (the square is empty or occupied by an opponent's piece), or 0 if the square is occupied by a piece of the same color.
- **Functions Called**:
    - [`boardGetPiece`](<board.c.md#boardgetpiece>)
    - [`pieceGetColor`](<piece.c.md#piecegetcolor>)


---
### pmLeaperMoveList<!-- {{#callable:pmLeaperMoveList}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L26>)

Generates a list of valid moves for a leaper piece on a chessboard based on its movement directions.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chessboard.
    - `s`: The `sq` structure representing the current position of the piece on the board.
    - `pt`: The `pieceType` indicating the type of the piece for which moves are being generated.
    - `dirs`: A 2D array of integers representing the possible movement directions for the piece.
    - `numDirs`: The number of movement directions provided in the `dirs` array.
- **Logic and Control Flow**:
    - Create a new `moveList` to store possible moves.
    - Retrieve the piece at the given square `s` on the board `b`.
    - Check if the piece type matches the specified `pieceType` `pt`; if not, return the empty move list.
    - Determine the color of the piece at square `s`.
    - Iterate over each direction in the `dirs` array.
    - Calculate the new square by adding the direction offsets to the current square `s`.
    - Check if the new square is within the bounds of the board (1 to 8 for both file and rank).
    - If the new square is valid and can be moved to (no same-color piece), add the move to the `moveList`.
    - Return the populated `moveList` with all valid moves.
- **Output**: A pointer to a `moveList` containing all valid moves for the leaper piece from the given position.
- **Functions Called**:
    - [`moveListCreate`](<movelist.c.md#movelistcreate>)
    - [`boardGetPiece`](<board.c.md#boardgetpiece>)
    - [`pieceGetType`](<piece.c.md#piecegettype>)
    - [`pieceGetColor`](<piece.c.md#piecegetcolor>)
    - [`canMoveHere`](<#canmovehere>)
    - [`moveListAdd`](<movelist.c.md#movelistadd>)
    - [`moveSq`](<move.c.md#movesq>)


---
### pmRiderMoveList<!-- {{#callable:pmRiderMoveList}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L52>)

Generates a list of possible moves for a rider-type chess piece from a given position on the board.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chessboard.
    - `s`: The `sq` structure representing the current square of the piece on the board.
    - `pt`: The `pieceType` enumeration value representing the type of the piece to move.
    - `dirs`: A 2D array of integers representing the possible movement directions for the piece.
    - `numDirs`: The number of directions in the `dirs` array.
- **Logic and Control Flow**:
    - Create a new move list using `moveListCreate()`.
    - Get the piece at the square `s` using `boardGetPiece(b, s)`.
    - Check if the piece type matches `pt`; if not, return the empty move list.
    - Get the color of the piece using `pieceGetColor(p)`.
    - Iterate over each direction in `dirs` using a loop.
    - For each direction, update the square `newSq` by adding the direction offsets to the current square `s`.
    - Check if `newSq` is within the board boundaries; if not, break the loop for that direction.
    - Get the piece at `newSq` using `boardGetPiece(b, newSq)`.
    - Check if the piece can move to `newSq` using `canMoveHere(b, newSq, color)`; if true, add the move to the list using `moveListAdd(list, moveSq(s, newSq))`.
    - If `newSq` contains a piece (not `pEmpty`), break the loop for that direction.
    - Return the move list.
- **Output**: A pointer to a `moveList` structure containing all valid moves for the piece from the given square.
- **Functions Called**:
    - [`moveListCreate`](<movelist.c.md#movelistcreate>)
    - [`boardGetPiece`](<board.c.md#boardgetpiece>)
    - [`pieceGetType`](<piece.c.md#piecegettype>)
    - [`pieceGetColor`](<piece.c.md#piecegetcolor>)
    - [`canMoveHere`](<#canmovehere>)
    - [`moveListAdd`](<movelist.c.md#movelistadd>)
    - [`moveSq`](<move.c.md#movesq>)


---
### addPawnMoveToMoveList<!-- {{#callable:addPawnMoveToMoveList}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L95>)

Adds a pawn move to the move list, including promotion moves if applicable.
- **Inputs**:
    - ``list``: A pointer to a `moveList` where the pawn move will be added.
    - ``oldSq``: The starting square of the pawn.
    - ``newSq``: The destination square of the pawn.
- **Logic and Control Flow**:
    - Check if the destination square `newSq` is on the first or eighth rank, indicating a promotion opportunity.
    - If promotion is possible, add moves to the list for promoting the pawn to a queen, rook, bishop, and knight.
    - If promotion is not possible, add a regular move from `oldSq` to `newSq` to the list.
- **Output**: No return value; the function modifies the `moveList` pointed to by `list`.
- **Functions Called**:
    - [`moveListAdd`](<movelist.c.md#movelistadd>)
    - [`movePromote`](<move.c.md#movepromote>)
    - [`moveSq`](<move.c.md#movesq>)


---
### pmGetPawnMoves<!-- {{#callable:pmGetPawnMoves}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L111>)

Generates a list of all possible legal moves for a pawn located at a given square on a chess board.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chess board.
    - `s`: The `sq` structure representing the current position of the pawn on the board.
- **Logic and Control Flow**:
    - Create an empty move list using `moveListCreate()`.
    - Retrieve the piece at square `s` using `boardGetPiece(b, s)` and check if it is a pawn; if not, return the empty move list.
    - Determine the pawn's color and set `delta` to 1 for white pawns and -1 for black pawns.
    - Calculate the square directly in front of the pawn (`newSq`) and check if it is empty; if so, add this move to the list.
    - Check if the pawn is in its initial position and can move two squares forward; if so, add this move to the list if the path is clear.
    - Check for possible captures to the left and right of the pawn's current position; add these moves to the list if they are valid captures or en passant targets.
    - Return the list of possible moves.
- **Output**: A pointer to a `moveList` structure containing all possible legal moves for the pawn at the given square.
- **Functions Called**:
    - [`moveListCreate`](<movelist.c.md#movelistcreate>)
    - [`boardGetPiece`](<board.c.md#boardgetpiece>)
    - [`pieceGetType`](<piece.c.md#piecegettype>)
    - [`pieceGetColor`](<piece.c.md#piecegetcolor>)
    - [`sqI`](<square.c.md#sqi>)
    - [`addPawnMoveToMoveList`](<#addpawnmovetomovelist>)
    - [`canMoveHere`](<#canmovehere>)
    - [`sqEq`](<square.c.md#sqeq>)


---
### pmGetPawnAttacks<!-- {{#callable:pmGetPawnAttacks}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L162>)

Determines potential attack squares for a pawn on a chessboard.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chessboard.
    - `s`: The `sq` structure representing the current position of the pawn on the board.
- **Logic and Control Flow**:
    - Create a new `moveList` to store potential attack moves.
    - Retrieve the piece at square `s` using [`boardGetPiece`](<board.c.md#boardgetpiece>) and check if it is a pawn using [`pieceGetType`](<piece.c.md#piecegettype>).
    - If the piece is not a pawn, return the empty `moveList`.
    - Determine the pawn's color using [`pieceGetColor`](<piece.c.md#piecegetcolor>) and set `delta` to 1 for white pawns and -1 for black pawns.
    - Check if the pawn can attack diagonally to the left (file > 1) by calculating the new square and using [`canMoveHere`](<#canmovehere>) to verify if the move is possible.
    - If the move is possible, add it to the `moveList` using [`moveListAdd`](<movelist.c.md#movelistadd>).
    - Check if the pawn can attack diagonally to the right (file < 8) by calculating the new square and using [`canMoveHere`](<#canmovehere>) to verify if the move is possible.
    - If the move is possible, add it to the `moveList` using [`moveListAdd`](<movelist.c.md#movelistadd>).
    - Return the `moveList` containing all potential attack moves.
- **Output**: A pointer to a `moveList` containing potential attack moves for the pawn.
- **Functions Called**:
    - [`moveListCreate`](<movelist.c.md#movelistcreate>)
    - [`boardGetPiece`](<board.c.md#boardgetpiece>)
    - [`pieceGetType`](<piece.c.md#piecegettype>)
    - [`pieceGetColor`](<piece.c.md#piecegetcolor>)
    - [`sqI`](<square.c.md#sqi>)
    - [`canMoveHere`](<#canmovehere>)
    - [`moveListAdd`](<movelist.c.md#movelistadd>)
    - [`moveSq`](<move.c.md#movesq>)


---
### pmGetKnightMoves<!-- {{#callable:pmGetKnightMoves}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L197>)

Generates a list of valid moves for a knight piece on a chessboard from a given position.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chessboard.
    - `s`: The `sq` structure representing the current position of the knight on the board.
- **Logic and Control Flow**:
    - Calls the [`pmLeaperMoveList`](<#pmleapermovelist>) function with the board, current position, piece type `ptKnight`, `knightOffsets` array, and the number of directions (8).
- **Output**: A pointer to a `moveList` structure containing all possible moves for the knight from the given position.
- **Functions Called**:
    - [`pmLeaperMoveList`](<#pmleapermovelist>)


---
### pmGetBishopMoves<!-- {{#callable:pmGetBishopMoves}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L209>)

Generates a list of all possible moves for a bishop on a chessboard from a given position.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chessboard.
    - `s`: The `sq` structure representing the current position of the bishop on the board.
- **Logic and Control Flow**:
    - Calls the [`pmRiderMoveList`](<#pmridermovelist>) function with the board, position, piece type `ptBishop`, direction offsets `bishopOffsets`, and the number of directions `4`.
    - The [`pmRiderMoveList`](<#pmridermovelist>) function calculates all possible moves for the bishop by iterating over the diagonal directions specified in `bishopOffsets`.
- **Output**: Returns a pointer to a `moveList` structure containing all valid moves for the bishop from the given position.
- **Functions Called**:
    - [`pmRiderMoveList`](<#pmridermovelist>)


---
### pmGetRookMoves<!-- {{#callable:pmGetRookMoves}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L221>)

Generates a list of all possible moves for a rook on a given chess board from a specified square.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chess board.
    - `s`: The `sq` structure representing the square from which the rook will move.
- **Logic and Control Flow**:
    - Calls the [`pmRiderMoveList`](<#pmridermovelist>) function with the board `b`, square `s`, piece type `ptRook`, direction offsets `rookOffsets`, and number of directions `4`.
- **Output**: Returns a pointer to a `moveList` structure containing all valid moves for a rook from the specified square `s` on the board `b`.
- **Functions Called**:
    - [`pmRiderMoveList`](<#pmridermovelist>)


---
### pmGetQueenMoves<!-- {{#callable:pmGetQueenMoves}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L233>)

Generates a list of all possible moves for a queen on a chessboard from a given position.
- **Inputs**:
    - ``b``: A pointer to the `board` structure representing the current state of the chessboard.
    - ``s``: A `sq` structure representing the current position of the queen on the board.
- **Logic and Control Flow**:
    - Calls the [`pmRiderMoveList`](<#pmridermovelist>) function with the board, position, piece type `ptQueen`, direction offsets `royalOffsets`, and number of directions `8`.
    - The [`pmRiderMoveList`](<#pmridermovelist>) function calculates all possible moves for the queen by iterating over each direction in `royalOffsets` and moving in that direction until it reaches the edge of the board or another piece.
    - If the square is occupied by a piece of the same color, the move is not added to the list.
    - If the square is occupied by an opponent's piece, the move is added to the list and the iteration in that direction stops.
- **Output**: A pointer to a `moveList` structure containing all possible moves for the queen from the given position.
- **Functions Called**:
    - [`pmRiderMoveList`](<#pmridermovelist>)


---
### pmGetKingMoves<!-- {{#callable:pmGetKingMoves}} -->
[View Source →](<../../../../../chesslib/src/chesslib/piecemoves.c#L243>)

Generates a list of all possible moves for a king piece from a given square on a chess board.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chess board.
    - `s`: The `sq` structure representing the current position of the king on the board.
- **Logic and Control Flow**:
    - Calls the [`pmLeaperMoveList`](<#pmleapermovelist>) function with the board, square, piece type `ptKing`, direction offsets `royalOffsets`, and number of directions `8`.
    - The [`pmLeaperMoveList`](<#pmleapermovelist>) function generates moves for leaping pieces like the king, using the provided direction offsets.
- **Output**: A pointer to a `moveList` structure containing all valid moves for the king from the specified square.
- **Functions Called**:
    - [`pmLeaperMoveList`](<#pmleapermovelist>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)