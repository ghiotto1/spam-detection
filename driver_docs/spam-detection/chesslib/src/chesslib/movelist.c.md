<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements a move list for chess, including creation, addition, retrieval, undo, and UCI string conversion.

# Purpose
The code implements a linked list data structure specifically designed to manage a list of chess moves. It provides functions to create and manipulate a `moveList`, which is a collection of `moveListNode` elements. Each node in the list represents a single chess move. The primary operations include creating a new move list with [`moveListCreate`](<#movelistcreate>), adding a move to the list with [`moveListAdd`](<#movelistadd>), retrieving a move by index with [`moveListGet`](<#movelistget>), and removing the last move with [`moveListUndo`](<#movelistundo>). The code also includes a function [`moveListGetUciString`](<#movelistgetucistring>) to convert the list of moves into a Universal Chess Interface (UCI) formatted string, which is commonly used for communicating chess moves in software.

The code is part of a larger chess library, as indicated by the inclusion of the header file `chesslib/movelist.h`. It defines a public API for managing move lists, which can be used by other parts of the chess application. The [`moveListFree`](<#movelistfree>) function is provided to deallocate memory used by the move list, ensuring proper resource management. The implementation uses a singly linked list, which is evident from the use of `next` pointers in `moveListNode` and the absence of backward traversal capabilities. The code is intended to be part of a library and does not include a `main` function, indicating it is not an executable on its own.
# Imports and Dependencies

---
- `stdlib.h`
- `string.h`
- `chesslib/movelist.h`


# Functions

---
### moveListCreate<!-- {{#callable:moveListCreate}} -->
[View Source →](<../../../../../chesslib/src/chesslib/movelist.c#L11>)

Allocates and initializes a new `moveList` structure.
- **Inputs**: None
- **Logic and Control Flow**:
    - Allocate memory for a `moveList` structure using `malloc`.
    - Set the `head` pointer of the list to `NULL`.
    - Set the `tail` pointer of the list to `NULL`.
    - Initialize the `size` of the list to 0.
    - Return the pointer to the newly created `moveList`.
- **Output**: A pointer to a newly allocated and initialized `moveList` structure.


---
### moveListNodeCreate<!-- {{#callable:moveListNodeCreate}} -->
[View Source →](<../../../../../chesslib/src/chesslib/movelist.c#L22>)

Allocates memory for a new `moveListNode`, initializes it with a given `move`, and sets its `next` pointer to `NULL`.
- **Inputs**:
    - `move`: A `move` structure that contains the data to store in the new node.
- **Logic and Control Flow**:
    - Allocate memory for a `moveListNode` and assign it to `node`.
    - Set the `move` field of `node` to the input `move`.
    - Set the `next` pointer of `node` to `NULL`.
    - Return the pointer to the newly created `moveListNode`.
- **Output**: A pointer to the newly created `moveListNode`.


---
### moveListAdd<!-- {{#callable:moveListAdd}} -->
[View Source →](<../../../../../chesslib/src/chesslib/movelist.c#L31>)

Adds a new move to the end of a move list.
- **Inputs**:
    - `list`: A pointer to a `moveList` structure where the new move will be added.
    - `move`: The `move` to add to the `moveList`.
- **Logic and Control Flow**:
    - Create a new `moveListNode` using the provided `move` by calling [`moveListNodeCreate`](<#movelistnodecreate>).
    - Check if the `head` of the `list` is `NULL`.
    - If `head` is `NULL`, set both `head` and `tail` of the `list` to the new node.
    - If `head` is not `NULL`, set the `next` pointer of the current `tail` to the new node and update the `tail` to the new node.
    - Increment the `size` of the `list` by 1.
- **Output**: No return value; the function modifies the `moveList` in place.
- **Functions Called**:
    - [`moveListNodeCreate`](<#movelistnodecreate>)


---
### moveListGet<!-- {{#callable:moveListGet}} -->
[View Source →](<../../../../../chesslib/src/chesslib/movelist.c#L49>)

Retrieves the move at a specified index from a linked list of moves.
- **Inputs**:
    - `list`: A pointer to a `moveList` structure, which is a linked list of moves.
    - `index`: An unsigned integer representing the position of the move to retrieve from the list.
- **Logic and Control Flow**:
    - Initialize `currNode` to the head of the list.
    - Iterate through the list, moving to the next node and decrementing `index` until `index` is zero.
    - Return the move stored in the current node.
- **Output**: Returns the `move` located at the specified `index` in the `moveList`.


---
### moveListUndo<!-- {{#callable:moveListUndo}} -->
[View Source →](<../../../../../chesslib/src/chesslib/movelist.c#L60>)

Removes the last node from a singly linked list of moves, effectively undoing the last move.
- **Inputs**:
    - `list`: A pointer to a `moveList` structure, which represents a singly linked list of moves.
- **Logic and Control Flow**:
    - Check if `list` is `NULL` or if `list->head` is `NULL`; if so, return immediately.
    - Check if the list has only one node by verifying if `list->head->next` is `NULL`; if true, free the head node and set both `list->head` and `list->tail` to `NULL`.
    - If the list has more than one node, iterate through the list to find the last node and its previous node.
    - Free the last node, set the `next` pointer of the previous node to `NULL`, and update `list->tail` to point to the previous node.
    - Decrement the `size` of the list by one.
- **Output**: No return value; the function modifies the `moveList` structure in place.


---
### moveListGetUciString<!-- {{#callable:moveListGetUciString}} -->
[View Source →](<../../../../../chesslib/src/chesslib/movelist.c#L92>)

Converts a `moveList` into a UCI (Universal Chess Interface) formatted string.
- **Inputs**:
    - `list`: A pointer to a `moveList` structure that contains the moves to convert into a UCI string.
- **Logic and Control Flow**:
    - Check if the `moveList` is empty; if so, allocate a single character for the string, set it to null, and return it.
    - If the `moveList` contains one move, convert that move to a UCI string using [`moveGetUci`](<move.c.md#movegetuci>) and return it.
    - Calculate the required size for the UCI string by considering 4 characters per move, a space between moves, and an additional byte for each promotion character.
    - Allocate memory for the UCI string based on the calculated size.
    - Iterate through each move in the `moveList`, convert it to a UCI string, append it to the result string, and add a space after each move.
    - Replace the last space with a null terminator to properly end the string.
    - Return the constructed UCI string.
- **Output**: A dynamically allocated string containing the UCI representation of the moves in the `moveList`. The caller is responsible for freeing this string.
- **Functions Called**:
    - [`moveGetUci`](<move.c.md#movegetuci>)


---
### moveListFree<!-- {{#callable:moveListFree}} -->
[View Source →](<../../../../../chesslib/src/chesslib/movelist.c#L141>)

Deallocates memory for a `moveList` and all its nodes.
- **Inputs**:
    - `list`: A pointer to a `moveList` structure that contains the list of moves to free.
- **Logic and Control Flow**:
    - Initialize `node` to the head of the list.
    - Enter a loop that continues while `node` is not NULL.
    - Inside the loop, store the next node in `next`.
    - Free the current `node`.
    - Set `node` to `next` to move to the next node in the list.
    - After the loop, free the `list` itself.
- **Output**: No return value; the function frees memory.



---
Made with ❤️ by [Driver](https://www.driver.ai/)